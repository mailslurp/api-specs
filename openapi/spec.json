{"openapi":"3.0.1","info":{"title":"MailSlurp API","description":"MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.\n\n## Resources\n\n- [Homepage](https://www.mailslurp.com)\n- Get an [API KEY](https://app.mailslurp.com/sign-up/)\n- Generated [SDK Clients](https://www.mailslurp.com/docs/)\n- [Examples](https://github.com/mailslurp/examples) repository","contact":{"url":"https://www.mailslurp.com/contact/","email":"contact@mailslurp.dev"},"license":{"name":"Apache 2.0","url":"https://www.mailslurp.com"},"version":"6.5.2"},"externalDocs":{"description":"MailSlurp API documentation","url":"https://www.mailslurp.com"},"servers":[{"url":"https://api.mailslurp.com","description":"MailSlurp API Server"}],"security":[{"API_KEY":[]}],"tags":[{"name":"AliasController","description":"\"Endpoints for creating, listing, and deleting email aliases. Aliases must be validated. Email aliases can be used to hide real email addresses behind an alias. If you wish to receive emails with an alias attach an inbox to the alias.\n       Whenever the inbox receives an email the email will be forwarded to the alias email address. See related `threads`. Threads can be used with aliases to enable replying to a proxied email. This means that when threads are enabled an email alias will \n       create a new email thread for the message and set the replyTo and from headers on the subsequently proxied email to point to the threads unique email address. \n       By replying to this address the thread will forward it to the original emails sender or replyTo and use the same subject and bcc and cc contacts as the email you are replying to. For more advanced email operations using aliases use the inboxId for the given alias.\n"},{"name":"DomainController","description":"Endpoints for managing custom domains. Once you create a custom domain you must add the returned verification records to your hosting provider. See support or guides for more information."},{"name":"EmailController","description":"Endpoints for managing email entities. Send and read email using the email API. You can fetch emails and attachments, reply to emails, and send new emails with this controller. Emails belong to inboxes. \nEach inbox can contain unlimited emails that are either permanent or temporary depending on your setup. Because emails can be quite large when attachments and content are fetched most responses only include a preview of the email and its most important features, like subject, recipients etc and an ID. Many list results are in a paginated form using an index (zero based) and a page size. To receive email decide on either `waitFor` methods (such as `waitForLatestEmail` on the `WaitForController`) to wait for emails to arrive. Use `getEmails` on `EmailController` or `getInboxEmails` on the `InboxController` to list existing emails. To access the body or attachments of an email you need to use the `getEmail` and `getAttachment` endpoints with specific inbox and email IDs. The body is returned on full email entities and contains the parsed body of the email. The email headers (such as recipients, subject etc.) are stored on the email object. You can access the RAW SMTP message via various `raw` methods. Attachments are treated as separate entities that have an ID and belong to the email. To fetch email attachments first fetch the full email then use a `downloadAttachment` method for each `attachmentID`. Attachments are transferred in a number of ways as either `application/octect-stream` byte arrays or as base64 encoded strings with meta data. You may prefer either depending on the environment you are in but the base64 implementations are typically safer. See the `AttachmentController`, `InboxController`, and `WaitForController` for similar methods. \n    "},{"name":"TrackingController","description":"Endpoints for managing tracking entities such as email open and read tracking pixels."},{"name":"WaitForController","description":"Endpoints for receiving emails using waitFor methods. The endpoints are perfect for synchronous blocking calls, long-polling, or tests (see webhooks if you need to respond to email events as they happen using HTTP notification). These wait endpoints are all built around a common idea - that you ask for an expected number of emails from an inbox and MailSlurp will either: A) Return the matching emails if they are present; B) Hold a connection open until the matching emails are are received or until a timeout occurs. For test suites we recommend that you create a new inbox for each test run  and use the waitForLatestEmail to hold the connection until the email you expect arrives. Note if your inbox is not already empty waitFor methods may return immediately depending on their implementation. See each endpoint for more details."},{"name":"FormController","description":"Form controller for submitting email-able forms"},{"name":"InboxForwarderController","description":"Endpoints for creating and managing inbox forwarders. Automatically forward emails received by inboxes using rules."},{"name":"EmailVerificationController"},{"name":"CommonActionsController","description":"A collection of common actions. Groups together several controllers behind a facade with convenience methods. Not recommended. It is better in most cases to call the individual controllers directly as they are where many new features are added. The controllers are better documented too. This controller is maintained for backwards compatibility."},{"name":"SentEmailsController","description":"Endpoints for viewing sent email receipts. These can be used to verify that an email has been sent or for historical records. Email content and attachments are stored. For legacy reasons the default send endpoint does not return a sent email. Use the `sendEmailAndConfirm` methods to receive a sent email receipt after sending."},{"name":"BounceController","description":"Endpoints for access bounced emails and bounced recipients"},{"name":"InboxController","description":"Endpoints for creating and managing inboxes. Also includes endpoints for listing emails within inboxes. \nInboxes are a core feature of MailSlurp. Each inbox has a unique ID and emailAddress. Inboxes can be either `HTTP` or `SMTP` inboxes. Both are email inboxes but `HTTP` mailboxes are processed using AWS SES while `SMTP` inboxes use a custom mail server listening at `mx.mailslurp.com`. Use `HTTP` inboxes for testing and `SMTP` inboxes for public facing inboxes. If your plan allows custom domains you can create inboxes with custom addresses that end in your domain. \nBy default inboxes are assigned a random email address ending in `@mailslurp.com`. Use the domainPool options to use a randomly selected domain from a pool of available domains. Whenever you create an inbox MailSlurp will register the address and store any emails sent to the address within your inbox. \nYou can use the `InboxController` endpoints to list the emails in an inbox. To get the contents or attachments of an email use the ID returned from `InboxController` methods to call the `EmailController` endpoints.\"\n"},{"name":"ExportController","description":"Endpoints for exporting user data to CSV, XML and other formats."},{"name":"ExpiredController","description":"View and manage expired inbox records. If an inbox has an expiration date when it is created it will expire at that time and an ExpiredInboxRecord will be created for it listing the email address and inbox ID. You can still view emails belonging to the inbox by using the inbox ID but the inbox can no longer send or receive emails once expired."},{"name":"BulkActionsController","description":"Other endpoints including advanced receive options"},{"name":"ContactController","description":"Endpoints for managing contacts. Contacts can be used for sending emails to individuals and groups."},{"name":"GroupController","description":"Endpoints for managing groups. Groups can be used for sending emails to individuals and groups."},{"name":"MailServerController"},{"name":"InboxRulesetController","description":"Endpoints for creating and managing inbox rulesets. Inbox rulesets are sets of rules that can be automatically applied to inbound and outbound emails for an inbox. Rulesets can have a scope, action, and target. The scope is receiving or sending emails. The action is to block, allow, or forward an email. The target is pattern or email address depending on the action. The handler can be used to handle rules silently or trigger an exception when they occur. See inbox controller for similar methods.\n"},{"name":"TemplateController","description":"Endpoints for managing Templates. Templates can be used when sending emails and support moustache syntax template variables. Variables can be passed with send email options or implicitly available if Contact Groups are used."},{"name":"MissedEmailController","description":"Endpoints for managing MissedEmails. Missed emails are saved whenever your account cannot persist a received email because your plan had exceeded a given usage at the time."},{"name":"AttachmentController","description":"Endpoints for uploading attachments. Attachments can be uploaded in a number of ways: as base64 encoded strings, as byte array octet streams, and as multipart form requests. Each upload method returns an array whose first element is the ID of the attachment. Use this Id to send the attachment with emails. See the EmailController `download` endpoints for downloading attachments. Attachment downloads are based on the email ID they belong to and can be downloaded using the email controller."},{"name":"WebhookController","description":"Endpoint for interacting with webhooks. Webhooks have a URL that points to your server. Useful for email forwarding, email API processing and more. They can be added to inboxes and when an inbox receives an email the email ID and inbox ID will be posted to the URL endpoint at your server. The schema of the webhook payload is available at https://api.mailslurp.com/schemas/webhook-payload or by calling https://api.mailslurp.com/webhooks/test. Use webhooks to react in real-time to inbound emails. Use the webhook payload posted to your server to fetch the full emails or attachments if you need them. Use the event ID as an idempotent record. The ID identifies the webhook payload uniquely. MailSlurp tracks webhook processing. It will try not to send the same event twice but it can happen. If you receive the same event more than once you can ignore it and assume it is the same. It is recommended that you use a store or database to track webhooks you have processed to avoid processing events more than once."}],"paths":{"/templates/{templateId}":{"get":{"tags":["TemplateController"],"summary":"Get Template","operationId":"getTemplate","parameters":[{"name":"templateId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/TemplateDto"}}}}}},"put":{"tags":["TemplateController"],"summary":"Update a Template","operationId":"updateTemplate","parameters":[{"name":"templateId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateTemplateOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/TemplateDto"}}}}}},"delete":{"tags":["TemplateController"],"summary":"Delete Template","operationId":"deleteTemplate","parameters":[{"name":"templateId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/rulesets":{"get":{"tags":["InboxRulesetController"],"summary":"List inbox rulesets","description":"List all rulesets attached to an inbox","operationId":"getInboxRulesets","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox id to get rulesets from","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox ruleset list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox ruleset list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageInboxRulesetDto"}}}}}},"put":{"tags":["InboxRulesetController"],"summary":"Test inbox rulesets for inbox","description":"Test inbox rulesets for inbox","operationId":"testInboxRulesetsForInbox","parameters":[{"name":"inboxId","in":"query","description":"ID of inbox","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/InboxRulesetTestOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetTestResult"}}}}}},"post":{"tags":["InboxRulesetController"],"summary":"Create an inbox ruleset","description":"Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving","operationId":"createNewInboxRuleset","parameters":[{"name":"inboxId","in":"query","description":"Inbox id to attach ruleset to","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateInboxRulesetOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetDto"}}}}}},"delete":{"tags":["InboxRulesetController"],"summary":"Delete inbox rulesets","description":"Delete inbox rulesets. Accepts optional inboxId filter.","operationId":"deleteInboxRulesets","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox id to attach ruleset to","required":false,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}},"patch":{"tags":["InboxRulesetController"],"summary":"Test new inbox ruleset","description":"Test new inbox ruleset","operationId":"testNewInboxRuleset","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/TestNewInboxRulesetOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetTestResult"}}}}}}},"/inboxes/{inboxId}/favourite":{"put":{"tags":["InboxController"],"summary":"Set inbox favourited state","description":"Set and return new favourite state for an inbox","operationId":"setInboxFavourited","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SetInboxFavouritedOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/groups/{groupId}/contacts":{"get":{"tags":["GroupController"],"summary":"Get group and contacts belonging to it","operationId":"getGroupWithContacts","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GroupContactsDto"}}}}}},"put":{"tags":["GroupController"],"summary":"Add contacts to a group","operationId":"addContactsToGroup","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateGroupContacts"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GroupContactsDto"}}}}}},"delete":{"tags":["GroupController"],"summary":"Remove contacts from a group","operationId":"removeContactsFromGroup","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateGroupContacts"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GroupContactsDto"}}}}}}},"/forwarders":{"get":{"tags":["InboxForwarderController"],"summary":"List inbox forwarders","description":"List all forwarders attached to an inbox","operationId":"getInboxForwarders","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox id to get forwarders from","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox forwarder list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox forwarder list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageInboxForwarderDto"}}}}}},"put":{"tags":["InboxForwarderController"],"summary":"Test inbox forwarders for inbox","description":"Test inbox forwarders for inbox","operationId":"testInboxForwardersForInbox","parameters":[{"name":"inboxId","in":"query","description":"ID of inbox","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/InboxForwarderTestOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxForwarderTestResult"}}}}}},"post":{"tags":["InboxForwarderController"],"summary":"Create an inbox forwarder","description":"Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving","operationId":"createNewInboxForwarder","parameters":[{"name":"inboxId","in":"query","description":"Inbox id to attach forwarder to","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateInboxForwarderOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxForwarderDto"}}}}}},"delete":{"tags":["InboxForwarderController"],"summary":"Delete inbox forwarders","description":"Delete inbox forwarders. Accepts optional inboxId filter.","operationId":"deleteInboxForwarders","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox id to attach forwarder to","required":false,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}},"patch":{"tags":["InboxForwarderController"],"summary":"Test new inbox forwarder","description":"Test new inbox forwarder","operationId":"testNewInboxForwarder","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/TestNewInboxForwarderOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxForwarderTestResult"}}}}}}},"/emails/{emailId}":{"get":{"tags":["EmailController"],"summary":"Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.","description":"Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints","operationId":"getEmail","parameters":[{"name":"emailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"decode","in":"query","description":"Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance `=D7`). This can be a pain for testing","required":false,"schema":{"type":"boolean","default":false}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}},"put":{"tags":["EmailController"],"summary":"Reply to an email","description":"Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.","operationId":"replyToEmail","parameters":[{"name":"emailId","in":"path","description":"ID of the email that should be replied to","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReplyToEmailOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}},"delete":{"tags":["EmailController"],"summary":"Delete an email","description":"Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.","operationId":"deleteEmail","parameters":[{"name":"emailId","in":"path","description":"ID of email to delete","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/domains/{id}":{"get":{"tags":["DomainController"],"summary":"Get a domain","description":"Returns domain verification status and tokens for a given domain","operationId":"getDomain","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DomainDto"}}}}}},"put":{"tags":["DomainController"],"summary":"Update a domain","description":"Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.","operationId":"updateDomain","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateDomainOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DomainDto"}}}}}},"delete":{"tags":["DomainController"],"summary":"Delete a domain","description":"Delete a domain. This will disable any existing inboxes that use this domain.","operationId":"deleteDomain","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content","content":{"*/*":{"schema":{"type":"array","items":{"type":"string"}}}}}}}},"/aliases/{aliasId}":{"get":{"tags":["AliasController"],"summary":"Get an email alias","description":"Get an email alias by ID","operationId":"getAlias","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AliasDto"}}}}}},"put":{"tags":["AliasController"],"summary":"Update an email alias","operationId":"updateAlias","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateAliasOptions"}}},"required":true},"responses":{"202":{"description":"Accepted","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AliasDto"}}}}}},"delete":{"tags":["AliasController"],"summary":"Delete an email alias","operationId":"deleteAlias","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/aliases/{aliasId}/emails/{emailId}":{"put":{"tags":["AliasController"],"summary":"Reply to an email","description":"Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.","operationId":"replyToAliasEmail","parameters":[{"name":"aliasId","in":"path","description":"ID of the alias that email belongs to","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"emailId","in":"path","description":"ID of the email that should be replied to","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ReplyToAliasEmailOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}}},"/webhooks/{webhookId}/test":{"post":{"tags":["WebhookController"],"summary":"Send webhook test data","operationId":"sendTestData","parameters":[{"name":"webhookId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookTestResult"}}}}}}},"/webhooks/{webhookId}/schema":{"post":{"tags":["WebhookController"],"description":"Get JSON Schema definition for webhook payload","operationId":"getJsonSchemaForWebhookPayload","parameters":[{"name":"webhookId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/JSONSchemaDto"}}}}}}},"/webhooks/{webhookId}/example":{"post":{"tags":["WebhookController"],"description":"Get example payload for webhook","operationId":"getTestWebhookPayloadForWebhook","parameters":[{"name":"webhookId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AbstractWebhookPayload"}}}}}}},"/webhooks/results/{webhookResultId}/redrive":{"post":{"tags":["WebhookController"],"summary":"Get a webhook result and try to resend the original webhook payload","description":"Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.","operationId":"redriveWebhookResult","parameters":[{"name":"webhookResultId","in":"path","description":"Webhook Result ID","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookRedriveResult"}}}}}}},"/waitFor":{"post":{"tags":["WaitForController"],"summary":"Wait for an email to match the provided filter conditions such as subject contains keyword.","description":"Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met","operationId":"waitFor","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/WaitForConditions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/EmailPreview"}}}}}}}},"/waitForMatchingFirstEmail":{"post":{"tags":["WaitForController"],"summary":"Wait for or return the first email that matches provided MatchOptions array","description":"Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.","operationId":"waitForMatchingFirstEmail","parameters":[{"name":"inboxId","in":"query","description":"Id of the inbox we are matching an email for","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"timeout","in":"query","description":"Max milliseconds to wait","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread only","required":false,"schema":{"type":"boolean","default":false}},{"name":"since","in":"query","description":"Filter for emails that were received after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter for emails that were received before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"sort","in":"query","description":"Sort direction","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"delay","in":"query","description":"Max milliseconds delay between calls","required":false,"schema":{"type":"integer","format":"int64"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/MatchOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/waitForMatchingEmails":{"post":{"tags":["WaitForController"],"summary":"Wait or return list of emails that match simple matching patterns","description":"Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.","operationId":"waitForMatchingEmails","parameters":[{"name":"inboxId","in":"query","description":"Id of the inbox we are fetching emails from","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"count","in":"query","description":"Number of emails to wait for. Must be greater or equal to 1","required":true,"schema":{"minimum":1,"type":"integer","format":"int32"}},{"name":"before","in":"query","description":"Filter for emails that were received before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"since","in":"query","description":"Filter for emails that were received after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"sort","in":"query","description":"Sort direction","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"delay","in":"query","description":"Max milliseconds delay between calls","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"timeout","in":"query","description":"Max milliseconds to wait","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread only","required":false,"schema":{"type":"boolean","default":false}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/MatchOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/EmailPreview"}}}}}}}},"/tracking/pixels":{"get":{"tags":["TrackingController"],"summary":"Get tracking pixels","description":"List tracking pixels in paginated form","operationId":"getAllTrackingPixels","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageTrackingPixelProjection"}}}}}},"post":{"tags":["TrackingController"],"summary":"Create tracking pixel","description":"Create a tracking pixel. A tracking pixel is an image that can be embedded in an email. When the email is viewed and the image is seen MailSlurp will mark the pixel as seen. Use tracking pixels to monitor email open events. You can receive open notifications via webhook or by fetching the pixel.","operationId":"createTrackingPixel","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateTrackingPixelOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/TrackingPixelDto"}}}}}}},"/templates":{"get":{"tags":["TemplateController"],"summary":"Get all Templates","operationId":"getTemplates","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/TemplateProjection"}}}}}}},"post":{"tags":["TemplateController"],"summary":"Create a Template","operationId":"createTemplate","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateTemplateOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/TemplateDto"}}}}}}},"/sendEmail":{"post":{"tags":["CommonActionsController"],"summary":"Send an email","description":"If no senderId or inboxId provided a random email address will be used to send from.","operationId":"sendEmailSimple","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SimpleSendEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created"}}}},"/rulesets/{id}/test":{"post":{"tags":["InboxRulesetController"],"summary":"Test an inbox ruleset","description":"Test an inbox ruleset","operationId":"testInboxRuleset","parameters":[{"name":"id","in":"path","description":"ID of inbox ruleset","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/InboxRulesetTestOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetTestResult"}}}}}}},"/newEmailAddress":{"post":{"tags":["CommonActionsController"],"summary":"Create new random inbox","description":"Returns an Inbox with an `id` and an `emailAddress`","operationId":"createNewEmailAddress","parameters":[{"name":"allowTeamAccess","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"useDomainPool","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"expiresAt","in":"query","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"expiresIn","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"emailAddress","in":"query","required":false,"schema":{"type":"string"}},{"name":"inboxType","in":"query","required":false,"schema":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]}},{"name":"description","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","in":"query","required":false,"schema":{"type":"string"}},{"name":"tags","in":"query","required":false,"schema":{"type":"array","items":{"type":"string"}}},{"name":"favourite","in":"query","required":false,"schema":{"type":"boolean"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/mail-server/verify/email-address":{"post":{"tags":["MailServerController"],"summary":"Deprecated. Use the EmailVerificationController methods for more accurate and reliable functionality. Verify the existence of an email address at a given mail server.","operationId":"verifyEmailAddress","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/VerifyEmailAddressOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailVerificationResult"}}}}},"deprecated":true}},"/mail-server/describe/ip-address":{"post":{"tags":["MailServerController"],"summary":"Get IP address for a domain","operationId":"getIpAddress","parameters":[{"name":"name","in":"query","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/IPAddressResult"}}}}}}},"/mail-server/describe/domain":{"post":{"tags":["MailServerController"],"summary":"Get DNS Mail Server records for a domain","operationId":"describeMailServerDomain","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DescribeDomainOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DescribeMailServerDomainResult"}}}}}}},"/mail-server/describe/dns-lookup":{"post":{"tags":["MailServerController"],"summary":"Lookup DNS records for a domain","operationId":"getDnsLookup","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/DNSLookupOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DNSLookupResults"}}}}}}},"/internal/saml/user":{"post":{"tags":["api-internal-controller"],"operationId":"getSamlUserOrCreate","parameters":[{"name":"key","in":"query","required":true,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/GetOrCreateSamlUserOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/UserDto"}}}}}}},"/inboxes":{"get":{"tags":["InboxController"],"summary":"List Inboxes and email addresses","description":"List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended and allows paginated access using a limit and sort parameter.","operationId":"getInboxes","parameters":[{"name":"size","in":"query","description":"Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated `getAllEmails` for larger queries.","required":false,"schema":{"maximum":100,"type":"integer","format":"int32","default":100}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Optional filter by created after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by created before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InboxDto"}}}}}},"deprecated":true},"post":{"tags":["InboxController"],"summary":"Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either `SMTP` or `HTTP` inboxes.","description":"Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty. ","operationId":"createInbox","parameters":[{"name":"emailAddress","in":"query","description":"A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as `123@mailslurp.com`. If you use the `useDomainPool` option when the email address is null it will generate an email address with a more varied domain ending such as `123@mailslurp.info` or `123@mailslurp.biz`. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so `SMTP` inboxes will only work with `SMTP` type domains. Avoid `SMTP` inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.","required":false,"schema":{"type":"string"}},{"name":"tags","in":"query","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","required":false,"schema":{"type":"array","items":{"type":"string"}}},{"name":"name","in":"query","description":"Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.","required":false,"schema":{"type":"string"}},{"name":"description","in":"query","description":"Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with","required":false,"schema":{"type":"string"}},{"name":"useDomainPool","in":"query","description":"Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default `@mailslurp.com` email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in `@mailslurp.{world,info,xyz,...}` . This means a TLD is randomly selecting from a list of `.biz`, `.info`, `.xyz` etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of `@mailslurp.com` or custom email address provided by the emailAddress field. Note this feature is only available for `HTTP` inbox types.","required":false,"schema":{"type":"boolean"}},{"name":"favourite","in":"query","description":"Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering","required":false,"schema":{"type":"boolean"}},{"name":"expiresAt","in":"query","description":"Optional inbox expiration date. If null then this inbox is permanent and the emails in it won't be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd'T'HH:mm:ss.SSSXXX.","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"expiresIn","in":"query","description":"Number of milliseconds that inbox should exist for","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"allowTeamAccess","in":"query","description":"DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization.","required":false,"schema":{"type":"boolean"}},{"name":"inboxType","in":"query","description":"HTTP (default) or SMTP inbox type. HTTP inboxes are default and best solution for most cases. SMTP inboxes are more reliable for public inbound email consumption (but do not support sending emails). When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at `mx.mailslurp.com`.","required":false,"schema":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}},"delete":{"tags":["InboxController"],"summary":"Delete all inboxes","description":"Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.","operationId":"deleteAllInboxes","responses":{"204":{"description":"No Content"}}}},"/inboxes/{inboxId}":{"get":{"tags":["InboxController"],"summary":"Get Inbox. Returns properties of an inbox.","description":"Returns an inbox's properties, including its email address and ID.","operationId":"getInbox","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}},"post":{"tags":["InboxController"],"summary":"Send Email","description":"Send an email from an inbox's email address. \nThe request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.","operationId":"sendEmail","parameters":[{"name":"inboxId","in":"path","description":"ID of the inbox you want to send the email from","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SendEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created"}}},"delete":{"tags":["InboxController"],"summary":"Delete inbox","description":"Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.","operationId":"deleteInbox","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}},"patch":{"tags":["InboxController"],"summary":"Update Inbox. Change name and description. Email address is not editable.","description":"Update editable fields on an inbox","operationId":"updateInbox","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UpdateInboxOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/inboxes/{inboxId}/webhooks":{"get":{"tags":["WebhookController"],"summary":"Get all webhooks for an Inbox","operationId":"getWebhooks","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/WebhookDto"}}}}}}},"post":{"tags":["WebhookController"],"summary":"Attach a WebHook URL to an inbox","description":"Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.","operationId":"createWebhook","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateWebhookOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookDto"}}}}}}},"/inboxes/{inboxId}/smtp-envelope":{"post":{"tags":["InboxController"],"summary":"Send email using an SMTP mail envelope and message body and return sent confirmation","description":"Send email using an SMTP envelope containing RCPT TO, MAIL FROM, and a SMTP BODY.","operationId":"sendSmtpEnvelope","parameters":[{"name":"inboxId","in":"path","description":"ID of the inbox you want to send the email from","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SendSMTPEnvelopeOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}}},"/inboxes/{inboxId}/send-test-email":{"post":{"tags":["InboxController"],"summary":"Send a test email to inbox","description":"Send an inbox a test email to test email receiving is working","operationId":"sendTestEmail","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/inboxes/{inboxId}/rulesets":{"get":{"tags":["InboxController"],"summary":"List inbox rulesets","description":"List all rulesets attached to an inbox","operationId":"listInboxRulesets","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox ruleset list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox ruleset list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter by created after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by created before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageInboxRulesetDto"}}}}}},"post":{"tags":["InboxController"],"summary":"Create an inbox ruleset","description":"Create a new inbox rule for forwarding, blocking, and allowing emails when sending and receiving","operationId":"createInboxRuleset","parameters":[{"name":"inboxId","in":"path","description":"inboxId","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateInboxRulesetOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetDto"}}}}}}},"/inboxes/{inboxId}/confirm":{"post":{"tags":["InboxController"],"summary":"Send email and return sent confirmation","description":"Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.","operationId":"sendEmailAndConfirm","parameters":[{"name":"inboxId","in":"path","description":"ID of the inbox you want to send the email from","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SendEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}}},"/inboxes/withOptions":{"post":{"tags":["InboxController"],"summary":"Create an inbox with options. Extended options for inbox creation.","description":"Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.","operationId":"createInboxWithOptions","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateInboxDto"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/inboxes/withDefaults":{"post":{"tags":["InboxController"],"summary":"Create an inbox with default options. Uses MailSlurp domain pool address and is private.","operationId":"createInboxWithDefaults","responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/groups":{"get":{"tags":["GroupController"],"summary":"Get all groups","operationId":"getGroups","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/GroupProjection"}}}}}}},"post":{"tags":["GroupController"],"summary":"Create a group","operationId":"createGroup","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateGroupOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GroupDto"}}}}}}},"/forwarders/{id}/test":{"post":{"tags":["InboxForwarderController"],"summary":"Test an inbox forwarder","description":"Test an inbox forwarder","operationId":"testInboxForwarder","parameters":[{"name":"id","in":"path","description":"ID of inbox forwarder","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/InboxForwarderTestOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxForwarderTestResult"}}}}}}},"/forms":{"post":{"tags":["FormController"],"summary":"Submit a form to be parsed and sent as an email to an address determined by the form fields","description":"This endpoint allows you to submit HTML forms and receive the field values and files via email. \n\n#### Parameters\nThe endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email. \n\nYou must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`\n\nThe endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.\n\n#### Submitting\nThis endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.\n\n#### HTML Example\n```html\n<form \n  action=\"https://api.mailslurp.com/forms\"\n  method=\"post\"\n>\n  <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>\n  <textarea name=\"feedback\"></textarea>\n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n#### URL Example\n```html\n<form \n  action=\"https://api.mailslurp.com/forms?_to=test@example.com\"\n  method=\"post\"\n>\n  <textarea name=\"feedback\"></textarea>\n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n\n\nThe email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information). \nEndpoint accepts . \nYou can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.\n\n","operationId":"submitForm","parameters":[{"name":"_to","in":"query","description":"The email address that submitted form should be sent to.","required":false,"schema":{"type":"string"},"example":"test@example.com"},{"name":"_subject","in":"query","description":"Optional subject of the email that will be sent.","required":false,"schema":{"type":"string"},"example":"My form submission"},{"name":"_redirectTo","in":"query","description":"Optional URL to redirect form submitter to after submission. If not present user will see a success message.","required":false,"schema":{"type":"string"},"example":"https://mysite.com/form-success"},{"name":"_emailAddress","in":"query","description":"Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.","required":false,"schema":{"type":"string"},"example":"test@example.com"},{"name":"_successMessage","in":"query","description":"Optional success message to display if no _redirectTo present.","required":false,"schema":{"type":"string"},"example":"Thanks for submitting"},{"name":"_spamCheck","in":"query","description":"Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.","required":false,"schema":{"type":"string"}},{"name":"otherParameters","in":"query","description":"All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.","required":false,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"string"}}}}}}},"/export":{"get":{"tags":["ExportController"],"summary":"Export inboxes link callable via browser","operationId":"exportEntities","parameters":[{"name":"exportType","in":"query","required":true,"schema":{"type":"string","enum":["INBOXES","CONTACTS","ATTACHMENTS","EMAILS"]}},{"name":"apiKey","in":"query","required":true,"schema":{"type":"string"}},{"name":"outputFormat","in":"query","required":true,"schema":{"type":"string","enum":["CSV_DEFAULT","CSV_EXCEL"]}},{"name":"filter","in":"query","required":false,"schema":{"type":"string"}},{"name":"listSeparatorToken","in":"query","required":false,"schema":{"type":"string"}},{"name":"excludePreviouslyExported","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"createdEarliestTime","in":"query","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"createdOldestTime","in":"query","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"type":"string","format":"byte"}}}}}}},"post":{"tags":["ExportController"],"summary":"Get export link","operationId":"getExportLink","parameters":[{"name":"exportType","in":"query","required":true,"schema":{"type":"string","enum":["INBOXES","CONTACTS","ATTACHMENTS","EMAILS"]}},{"name":"apiKey","in":"query","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ExportOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ExportLink"}}}}}}},"/emails":{"get":{"tags":["EmailController"],"summary":"Get all emails in all inboxes in paginated form. Email API list all.","description":"By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages","operationId":"getEmailsPaginated","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.","required":false,"schema":{"type":"array","items":{"type":"string","format":"uuid"}}},{"name":"page","in":"query","description":"Optional page index in email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results","required":false,"schema":{"maximum":100,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly","required":false,"schema":{"type":"boolean","default":false}},{"name":"searchFilter","in":"query","description":"Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter emails received after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter emails received before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageEmailProjection"}}}}}},"post":{"tags":["EmailController"],"summary":"Send email","description":"Alias for `InboxController.sendEmail` method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.","operationId":"sendEmailSourceOptional","parameters":[{"name":"inboxId","in":"path","description":"ID of the inbox you want to send the email from","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"useDomainPool","in":"query","description":"Use domain pool. Optionally create inbox to send from using the mailslurp domain pool.","required":false,"schema":{"type":"boolean"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SendEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created"}}},"delete":{"tags":["EmailController"],"summary":"Delete all emails in all inboxes.","description":"Deletes all emails in your account. Be careful as emails cannot be recovered","operationId":"deleteAllEmails","responses":{"204":{"description":"No Content"}}}},"/emails/{emailId}/validate":{"post":{"tags":["EmailController"],"summary":"Validate email HTML contents","description":"Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.","operationId":"validateEmail","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ValidationDto"}}}}}}},"/emails/{emailId}/imap-flag-operation":{"post":{"tags":["EmailController"],"summary":"Set IMAP flags associated with a message. Only supports '\\Seen' flag.","description":"Apply RFC3501 section-2.3.2 IMAP flag operations on an email","operationId":"applyImapFlagOperation","parameters":[{"name":"emailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ImapFlagOperationOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailPreview"}}}}}}},"/emails/{emailId}/forward":{"post":{"tags":["EmailController"],"summary":"Forward email to recipients","description":"Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.","operationId":"forwardEmail","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ForwardEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}}},"/emails/{emailId}/contentMatch":{"post":{"tags":["EmailController"],"summary":"Get email content regex pattern match results. Runs regex against email body and returns match groups.","description":"Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. ","operationId":"getEmailContentMatch","parameters":[{"name":"emailId","in":"path","description":"ID of email to match against","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ContentMatchOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailContentMatchResult"}}}}}}},"/email-verification/email-address-list":{"post":{"tags":["EmailVerificationController"],"summary":"Validate a list of email addresses. Per unit billing. See your plan for pricing.","operationId":"validateEmailAddressList","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/ValidateEmailAddressListOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ValidateEmailAddressListResult"}}}}}}},"/domains":{"get":{"tags":["DomainController"],"summary":"Get domains","description":"List all custom domains you have created","operationId":"getDomains","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/DomainPreview"}}}}}}},"post":{"tags":["DomainController"],"summary":"Create Domain","description":"Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.","operationId":"createDomain","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateDomainOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DomainDto"}}}}}}},"/domains/{id}/wildcard":{"post":{"tags":["DomainController"],"summary":"Add catch all wild card inbox to domain","description":"Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated","operationId":"addDomainWildcardCatchAll","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DomainDto"}}}}}}},"/createInbox":{"post":{"tags":["CommonActionsController"],"summary":"Create new random inbox","description":"Returns an Inbox with an `id` and an `emailAddress`","operationId":"createRandomInbox","parameters":[{"name":"allowTeamAccess","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"useDomainPool","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"expiresAt","in":"query","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"expiresIn","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"emailAddress","in":"query","required":false,"schema":{"type":"string"}},{"name":"inboxType","in":"query","required":false,"schema":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]}},{"name":"description","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","in":"query","required":false,"schema":{"type":"string"}},{"name":"tags","in":"query","required":false,"schema":{"type":"array","items":{"type":"string"}}},{"name":"favourite","in":"query","required":false,"schema":{"type":"boolean"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"/contacts":{"get":{"tags":["ContactController"],"summary":"Get all contacts","operationId":"getContacts","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/ContactProjection"}}}}}}},"post":{"tags":["ContactController"],"summary":"Create a contact","operationId":"createContact","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateContactOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ContactDto"}}}}}}},"/bulk/send":{"post":{"tags":["BulkActionsController"],"summary":"Bulk Send Emails","operationId":"bulkSendEmails","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/BulkSendEmailOptions"}}},"required":true},"responses":{"201":{"description":"Created"}}}},"/bulk/inboxes":{"post":{"tags":["BulkActionsController"],"summary":"Bulk create Inboxes (email addresses)","operationId":"bulkCreateInboxes","parameters":[{"name":"count","in":"query","description":"Number of inboxes to be created in bulk","required":true,"schema":{"type":"integer","format":"int32"}}],"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/InboxDto"}}}}}}},"delete":{"tags":["BulkActionsController"],"summary":"Bulk Delete Inboxes","operationId":"bulkDeleteInboxes","requestBody":{"content":{"application/json":{"schema":{"type":"array","items":{"type":"string","format":"uuid"}}}},"required":true},"responses":{"204":{"description":"No Content"}}}},"/bounce/filter-recipients":{"post":{"tags":["BounceController"],"summary":"Filter a list of email recipients and remove those who have bounced","description":"Prevent email sending errors by remove recipients who have resulted in past email bounces or complaints","operationId":"filterBouncedRecipient","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/FilterBouncedRecipientsOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/FilterBouncedRecipientsResult"}}}}}}},"/attachments":{"get":{"tags":["AttachmentController"],"summary":"Get email attachments","description":"Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.","operationId":"getAttachments","parameters":[{"name":"page","in":"query","description":"Optional page index event list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size event list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"fileNameFilter","in":"query","description":"Optional file name and content type search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageAttachmentEntity"}}}}}},"post":{"tags":["AttachmentController"],"summary":"Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.","operationId":"uploadAttachment","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/UploadAttachmentOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"type":"array","items":{"type":"string"}}}}}}},"delete":{"tags":["AttachmentController"],"summary":"Delete all attachments","operationId":"deleteAllAttachments","responses":{"204":{"description":"No Content"}}}},"/attachments/multipart":{"post":{"tags":["AttachmentController"],"summary":"Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.","operationId":"uploadMultipartForm","parameters":[{"name":"contentType","in":"query","description":"Optional content type of attachment","required":false,"schema":{"type":"string"}},{"name":"filename","in":"query","description":"Optional name of file","required":false,"schema":{"type":"string"}},{"name":"x-filename","in":"query","description":"Optional content type header of attachment","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/json":{"schema":{"required":["file"],"type":"object","properties":{"contentTypeHeader":{"type":"string","description":"Optional content type header of attachment"},"file":{"type":"string","format":"binary"}}}}}},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"type":"array","items":{"type":"string"}}}}}}}},"/attachments/bytes":{"post":{"tags":["AttachmentController"],"summary":"Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.","operationId":"uploadAttachmentBytes","parameters":[{"name":"contentType","in":"header","description":"Optional contentType for file. For instance `application/pdf`","required":false,"schema":{"type":"string"}},{"name":"filename","in":"query","description":"Optional filename to save upload with","required":false,"schema":{"type":"string"}}],"requestBody":{"content":{"application/octet-stream":{"schema":{"type":"array","description":"Byte array request body","items":{"type":"string","format":"byte"}}}},"required":true},"responses":{"201":{"description":"Created","content":{"application/json":{"schema":{"type":"array","items":{"type":"string"}}}}}}}},"/aliases":{"get":{"tags":["AliasController"],"summary":"Get all email aliases you have created","description":"Get all email aliases in paginated form","operationId":"getAliases","parameters":[{"name":"page","in":"query","description":"Optional page index in alias list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in alias list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageAlias"}}}}}},"post":{"tags":["AliasController"],"summary":"Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.","description":"Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached","operationId":"createAlias","requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/CreateAliasOptions"}}},"required":true},"responses":{"201":{"description":"Created","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AliasDto"}}}}}}},"/aliases/{aliasId}/emails":{"get":{"tags":["AliasController"],"summary":"Get emails for an alias","description":"Get paginated emails for an alias by ID","operationId":"getAliasEmails","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index alias email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size alias email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Optional filter by sent after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by sent before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageEmailProjection"}}}}}},"post":{"tags":["AliasController"],"summary":"Send an email from an alias inbox","description":"Send an email from an alias. Replies to the email will be forwarded to the alias masked email address","operationId":"sendAliasEmail","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/SendEmailOptions"}}},"required":true},"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}}},"/emails/{emailId}/read":{"patch":{"tags":["EmailController"],"summary":"Mark an email as read on unread","description":"Marks an email as read or unread. Pass boolean read flag to set value. This is useful if you want to read an email but keep it as unread","operationId":"markAsRead","parameters":[{"name":"emailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"read","in":"query","description":"What value to assign to email read property. Default true.","required":false,"schema":{"type":"boolean","default":true}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailPreview"}}}}}}},"/webhooks/{webhookId}":{"get":{"tags":["WebhookController"],"summary":"Get a webhook for an Inbox","operationId":"getWebhook","parameters":[{"name":"webhookId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookDto"}}}}}}},"/webhooks/{webhookId}/results":{"get":{"tags":["WebhookController"],"summary":"Get a webhook results for a webhook","operationId":"getWebhookResults","parameters":[{"name":"webhookId","in":"path","description":"ID of webhook to get results for","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"unseenOnly","in":"query","description":"Filter for unseen exceptions only","required":false,"schema":{"type":"boolean"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageWebhookResult"}}}}}}},"/webhooks/test":{"get":{"tags":["WebhookController"],"description":"Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.","operationId":"getTestWebhookPayload","parameters":[{"name":"eventName","in":"query","required":false,"schema":{"type":"string","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AbstractWebhookPayload"}}}}}}},"/webhooks/test/new-email-payload":{"get":{"tags":["WebhookController"],"summary":"Get webhook test payload for new email event","operationId":"getTestWebhookPayloadNewEmail","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookNewEmailPayload"}}}}}}},"/webhooks/test/new-contact-payload":{"get":{"tags":["WebhookController"],"summary":"Get webhook test payload for new contact event","operationId":"getTestWebhookPayloadNewContact","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookNewContactPayload"}}}}}}},"/webhooks/test/new-attachment-payload":{"get":{"tags":["WebhookController"],"summary":"Get webhook test payload for new attachment event","operationId":"getTestWebhookPayloadNewAttachment","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookNewAttachmentPayload"}}}}}}},"/webhooks/test/email-read-payload":{"get":{"tags":["WebhookController"],"description":"Get webhook test payload for email opened event","operationId":"getTestWebhookPayloadEmailRead","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookEmailReadPayload"}}}}}}},"/webhooks/test/email-opened-payload":{"get":{"tags":["WebhookController"],"description":"Get webhook test payload for email opened event","operationId":"getTestWebhookPayloadEmailOpened","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookEmailOpenedPayload"}}}}}}},"/webhooks/results":{"get":{"tags":["WebhookController"],"summary":"Get results for all webhooks","operationId":"getAllWebhookResults","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"unseenOnly","in":"query","description":"Filter for unseen exceptions only","required":false,"schema":{"type":"boolean"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageWebhookResult"}}}}}}},"/webhooks/results/{webhookResultId}":{"get":{"tags":["WebhookController"],"summary":"Get a webhook result for a webhook","operationId":"getWebhookResult","parameters":[{"name":"webhookResultId","in":"path","description":"Webhook Result ID","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/WebhookResultDto"}}}}}}},"/webhooks/results/unseen-count":{"get":{"tags":["WebhookController"],"summary":"Get count of unseen webhook results with error status","operationId":"getWebhookResultsUnseenErrorCount","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/UnseenErrorCountDto"}}}}}}},"/webhooks/paginated":{"get":{"tags":["WebhookController"],"summary":"List Webhooks Paginated","description":"List webhooks in paginated form. Allows for page index, page size, and sort direction.","operationId":"getAllWebhooks","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"maximum":9223372036854775807,"minimum":0,"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size for paginated result list.","required":false,"schema":{"maximum":100,"minimum":1,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"DESC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageWebhookProjection"}}}}}}},"/waitForNthEmail":{"get":{"tags":["WaitForController"],"summary":"Wait for or fetch the email with a given index in the inbox specified. If index doesn't exist waits for it to exist or timeout to occur.","description":"If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.","operationId":"waitForNthEmail","parameters":[{"name":"inboxId","in":"query","description":"Id of the inbox you are fetching emails from","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"index","in":"query","description":"Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index=1","required":false,"schema":{"maximum":2147483647,"minimum":0,"type":"integer","format":"int32","default":0}},{"name":"timeout","in":"query","description":"Max milliseconds to wait for the nth email if not already present","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread only","required":false,"schema":{"type":"boolean","default":false}},{"name":"since","in":"query","description":"Filter for emails that were received after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter for emails that were received before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"sort","in":"query","description":"Sort direction","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"delay","in":"query","description":"Max milliseconds delay between calls","required":false,"schema":{"type":"integer","format":"int64"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/waitForLatestEmail":{"get":{"tags":["WaitForController"],"summary":"Fetch inbox's latest email or if empty wait for an email to arrive","description":"Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.","operationId":"waitForLatestEmail","parameters":[{"name":"inboxId","in":"query","description":"Id of the inbox we are fetching emails from","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"timeout","in":"query","description":"Max milliseconds to wait","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread only.","required":false,"schema":{"type":"boolean","default":false}},{"name":"before","in":"query","description":"Filter for emails that were before after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"since","in":"query","description":"Filter for emails that were received after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"sort","in":"query","description":"Sort direction","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"delay","in":"query","description":"Max milliseconds delay between calls","required":false,"schema":{"type":"integer","format":"int64"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/waitForEmailCount":{"get":{"tags":["WaitForController"],"summary":"Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs","description":"If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.","operationId":"waitForEmailCount","parameters":[{"name":"inboxId","in":"query","description":"Id of the inbox we are fetching emails from","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"count","in":"query","description":"Number of emails to wait for. Must be greater that 1","required":true,"schema":{"minimum":1,"type":"integer","format":"int32"}},{"name":"timeout","in":"query","description":"Max milliseconds to wait","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread only","required":false,"schema":{"type":"boolean","default":false}},{"name":"before","in":"query","description":"Filter for emails that were received before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"since","in":"query","description":"Filter for emails that were received after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"sort","in":"query","description":"Sort direction","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"delay","in":"query","description":"Max milliseconds delay between calls","required":false,"schema":{"type":"integer","format":"int64"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/EmailPreview"}}}}}}}},"/tracking/pixels/{id}":{"get":{"tags":["TrackingController"],"summary":"Get pixel","operationId":"getTrackingPixel","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/TrackingPixelDto"}}}}}}},"/templates/paginated":{"get":{"tags":["TemplateController"],"summary":"Get all Templates in paginated format","operationId":"getAllTemplates","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageTemplateProjection"}}}}}}},"/sent":{"get":{"tags":["SentEmailsController"],"summary":"Get all sent emails in paginated form","operationId":"getSentEmails","parameters":[{"name":"inboxId","in":"query","description":"Optional inboxId to filter sender of sent emails by","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageSentEmailProjection"}}}}}},"delete":{"tags":["SentEmailsController"],"summary":"Delete all sent email receipts","operationId":"deleteAllSentEmails","responses":{"204":{"description":"No Content"}}}},"/sent/{id}":{"get":{"tags":["SentEmailsController"],"summary":"Get sent email receipt","operationId":"getSentEmail","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/SentEmailDto"}}}}}},"delete":{"tags":["SentEmailsController"],"summary":"Delete sent email receipt","operationId":"deleteSentEmail","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/sent/{id}/urls":{"get":{"tags":["SentEmailsController"],"summary":"Get sent email URL for viewing in browser or downloading","description":"Get a list of URLs for sent email content as text/html or raw SMTP message for viewing the message in a browser.","operationId":"getSentEmailPreviewURLs","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailPreviewUrls"}}}}}}},"/sent/{id}/tracking-pixels":{"get":{"tags":["SentEmailsController"],"description":"Get all tracking pixels for a sent email in paginated form","operationId":"getSentEmailTrackingPixels","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in sent email tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in sent email tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageTrackingPixelProjection"}}}}}}},"/sent/{id}/html":{"get":{"tags":["SentEmailsController"],"summary":"Get sent email HTML content","operationId":"getSentEmailHTMLContent","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"text/html":{"schema":{"type":"string"}}}}}}},"/sent/{emailId}/raw":{"get":{"tags":["SentEmailsController"],"summary":"Get raw sent email string. Returns unparsed raw SMTP message with headers and body.","description":"Returns a raw, unparsed, and unprocessed sent email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawSentEmailJson endpoint","operationId":"getRawSentEmailContents","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/sent/{emailId}/raw/json":{"get":{"tags":["SentEmailsController"],"summary":"Get raw sent email in JSON. Unparsed SMTP message in JSON wrapper format.","description":"Returns a raw, unparsed, and unprocessed sent email wrapped in a JSON response object for easier handling when compared with the getRawSentEmail text/plain response","operationId":"getRawSentEmailJson","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/RawEmailJson"}}}}}}},"/sent/tracking-pixels":{"get":{"tags":["SentEmailsController"],"description":"Get all sent email tracking pixels in paginated form","operationId":"getAllSentTrackingPixels","parameters":[{"name":"page","in":"query","description":"Optional page index in sent email tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in sent email tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageTrackingPixelProjection"}}}}}}},"/sent/organization":{"get":{"tags":["SentEmailsController"],"description":"Get all sent organization emails in paginated form","operationId":"getSentOrganizationEmails","parameters":[{"name":"inboxId","in":"query","description":"Optional inboxId to filter sender of sent emails by","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageSentEmailProjection"}}}}}}},"/rulesets/{id}":{"get":{"tags":["InboxRulesetController"],"summary":"Get an inbox ruleset","description":"Get inbox ruleset","operationId":"getInboxRuleset","parameters":[{"name":"id","in":"path","description":"ID of inbox ruleset","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxRulesetDto"}}}}}},"delete":{"tags":["InboxRulesetController"],"summary":"Delete an inbox ruleset","description":"Delete inbox ruleset","operationId":"deleteInboxRuleset","parameters":[{"name":"id","in":"path","description":"ID of inbox ruleset","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/missed-emails":{"get":{"tags":["MissedEmailController"],"summary":"Get all MissedEmails in paginated format","operationId":"getAllMissedEmails","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"inboxId","in":"query","description":"Optional inbox ID filter","required":false,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageMissedEmailProjection"}}}}}}},"/missed-emails/{missedEmailId}":{"get":{"tags":["MissedEmailController"],"summary":"Get MissedEmail","operationId":"getMissedEmail","parameters":[{"name":"missedEmailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/MissedEmail"}}}}}}},"/missed-emails/waitForNthMissedEmail":{"get":{"tags":["MissedEmailController"],"summary":"Wait for Nth missed email","description":"Wait for 0 based index missed email","operationId":"waitForNthMissedEmail","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox ID filter","required":false,"schema":{"type":"string","format":"uuid"}},{"name":"timeout","in":"query","description":"Optional timeout milliseconds","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"index","in":"query","description":"Zero based index of the email to wait for. If 1 missed email already and you want to wait for the 2nd email pass index=1","required":true,"schema":{"maximum":2147483647,"minimum":0,"type":"integer","format":"int32"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/MissedEmail"}}}}}}},"/missed-emails/unknown":{"get":{"tags":["MissedEmailController"],"summary":"Get all unknown missed emails in paginated format","description":"Unknown missed emails are emails that were sent to MailSlurp but could not be assigned to an existing inbox.","operationId":"getAllUnknownMissedEmails","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"inboxId","in":"query","description":"Optional inbox ID filter","required":false,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageUnknownMissedEmailProjection"}}}}}}},"/inboxes/{inboxId}/webhooks/paginated":{"get":{"tags":["WebhookController"],"summary":"Get paginated webhooks for an Inbox","operationId":"getInboxWebhooksPaginated","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageWebhookProjection"}}}}}}},"/inboxes/{inboxId}/tracking-pixels":{"get":{"tags":["InboxController"],"summary":"List inbox tracking pixels","description":"List all tracking pixels sent from an inbox","operationId":"listInboxTrackingPixels","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox tracking pixel list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter by created after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by created before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageTrackingPixelProjection"}}}}}}},"/inboxes/{inboxId}/sent":{"get":{"tags":["InboxController"],"summary":"Get Inbox Sent Emails","description":"Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.","operationId":"getInboxSentEmails","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional sent email search","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter by sent after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by sent before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageSentEmailProjection"}}}}}}},"/inboxes/{inboxId}/emails":{"get":{"tags":["InboxController"],"summary":"Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.","description":"List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached","operationId":"getEmails","parameters":[{"name":"inboxId","in":"path","description":"Id of inbox that emails belongs to","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"size","in":"query","description":"Alias for limit. Assessed first before assessing any passed limit.","required":false,"schema":{"maximum":100,"type":"integer","format":"int32"}},{"name":"limit","in":"query","description":"Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller","required":false,"schema":{"maximum":100,"type":"integer","format":"int32"}},{"name":"sort","in":"query","description":"Sort the results by received date and direction ASC or DESC","required":false,"schema":{"type":"string","enum":["ASC","DESC"]}},{"name":"retryTimeout","in":"query","description":"Maximum milliseconds to spend retrying inbox database until minCount emails are returned","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"delayTimeout","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"minCount","in":"query","description":"Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"unreadOnly","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"before","in":"query","description":"Exclude emails received after this ISO 8601 date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"since","in":"query","description":"Exclude emails received before this ISO 8601 date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/EmailPreview"}}}}}}}},"/inboxes/{inboxId}/emails/paginated":{"get":{"tags":["InboxController"],"summary":"Get inbox emails paginated","description":"Get a paginated list of emails in an inbox. Does not hold connections open.","operationId":"getInboxEmailsPaginated","parameters":[{"name":"page","in":"query","description":"Optional page index in inbox emails list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox emails list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Optional filter by received after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by received before given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"inboxId","in":"path","description":"Id of inbox that emails belongs to","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageEmailPreview"}}}}}}},"/inboxes/{inboxId}/emails/count":{"get":{"tags":["InboxController"],"summary":"Get email count in inbox","operationId":"getInboxEmailCount","parameters":[{"name":"inboxId","in":"path","description":"Id of inbox that emails belongs to","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/CountDto"}}}}}}},"/inboxes/tags":{"get":{"tags":["InboxController"],"summary":"Get inbox tags","description":"Get all inbox tags","operationId":"getInboxTags","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"type":"string"}}}}}}}},"/inboxes/paginated":{"get":{"tags":["InboxController"],"summary":"List All Inboxes Paginated","description":"List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results.","operationId":"getAllInboxes","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"favourite","in":"query","description":"Optionally filter results for favourites only","required":false,"schema":{"type":"boolean","default":false}},{"name":"search","in":"query","description":"Optionally filter by search words partial matching ID, tags, name, and email address","required":false,"schema":{"type":"string"}},{"name":"tag","in":"query","description":"Optionally filter by tags. Will return inboxes that include given tags","required":false,"schema":{"type":"string"}},{"name":"teamAccess","in":"query","description":"DEPRECATED. Optionally filter by team access.","required":false,"deprecated":true,"schema":{"type":"boolean"}},{"name":"since","in":"query","description":"Optional filter by created after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by created before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageInboxProjection"}}}}}}},"/inboxes/organization":{"get":{"tags":["InboxController"],"summary":"List Organization Inboxes Paginated","description":"List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). ","operationId":"getOrganizationInboxes","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter by created after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by created before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageOrganizationInboxProjection"}}}}}}},"/inboxes/imap-smtp-access":{"get":{"tags":["InboxController"],"description":"Get IMAP and SMTP access usernames and passwords","operationId":"getImapSmtpAccess","parameters":[{"name":"inboxId","in":"query","description":"Inbox ID","required":false,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ImapSmtpAccessDetails"}}}}}}},"/inboxes/ids":{"get":{"tags":["InboxController"],"summary":"Get all inbox IDs","description":"Get list of inbox IDs","operationId":"getInboxIds","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxIdsResult"}}}}}}},"/inboxes/getLatestEmail":{"get":{"tags":["InboxController"],"summary":"Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.","description":"Get the newest email in an inbox or wait for one to arrive","operationId":"getLatestEmailInInbox","parameters":[{"name":"inboxId","in":"query","description":"ID of the inbox you want to get the latest email from","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"timeoutMillis","in":"query","description":"Timeout milliseconds to wait for latest email","required":true,"schema":{"type":"integer","format":"int64"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/inboxes/exists":{"get":{"tags":["InboxController"],"summary":"Does inbox exist","description":"Check if inboxes exist by email address. Useful if you are sending emails to mailslurp addresses","operationId":"doesInboxExist","parameters":[{"name":"emailAddress","in":"query","description":"Email address","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxExistsDto"}}}}}}},"/inboxes/count":{"get":{"tags":["InboxController"],"summary":"Get total inbox count","operationId":"getInboxCount","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/CountDto"}}}}}}},"/inboxes/byEmailAddress":{"get":{"tags":["InboxController"],"summary":"Search for an inbox with the provided email address","description":"Get a inbox result by email address","operationId":"getInboxByEmailAddress","parameters":[{"name":"emailAddress","in":"query","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxByEmailAddressResult"}}}}}}},"/groups/{groupId}":{"get":{"tags":["GroupController"],"summary":"Get group","operationId":"getGroup","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GroupDto"}}}}}},"delete":{"tags":["GroupController"],"summary":"Delete group","operationId":"deleteGroup","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/groups/{groupId}/contacts-paginated":{"get":{"tags":["GroupController"],"description":"Get group and paginated contacts belonging to it","operationId":"getGroupWithContactsPaginated","parameters":[{"name":"groupId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in group contact pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in group contact pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageContactProjection"}}}}}}},"/groups/paginated":{"get":{"tags":["GroupController"],"summary":"Get all Contact Groups in paginated format","operationId":"getAllGroups","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageGroupProjection"}}}}}}},"/forwarders/{id}":{"get":{"tags":["InboxForwarderController"],"summary":"Get an inbox forwarder","description":"Get inbox ruleset","operationId":"getInboxForwarder","parameters":[{"name":"id","in":"path","description":"ID of inbox forwarder","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/InboxForwarderDto"}}}}}},"delete":{"tags":["InboxForwarderController"],"summary":"Delete an inbox forwarder","description":"Delete inbox forwarder","operationId":"deleteInboxForwarder","parameters":[{"name":"id","in":"path","description":"ID of inbox forwarder","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/expired":{"get":{"tags":["ExpiredController"],"summary":"List records of expired inboxes","description":"Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties","operationId":"getExpiredInboxes","parameters":[{"name":"page","in":"query","description":"Optional page index in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in inbox sent email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageExpiredInboxRecordProjection"}}}}}}},"/expired/{expiredId}":{"get":{"tags":["ExpiredController"],"summary":"Get an expired inbox record","description":"Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties","operationId":"getExpiredInboxRecord","parameters":[{"name":"expiredId","in":"path","description":"ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ExpiredInboxDto"}}}}}}},"/expired/inbox/{inboxId}":{"get":{"tags":["ExpiredController"],"summary":"Get expired inbox record for a previously existing inbox","description":"Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId","operationId":"getExpiredInboxByInboxId","parameters":[{"name":"inboxId","in":"path","description":"ID of inbox you want to retrieve (not the inbox ID)","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ExpiredInboxDto"}}}}}}},"/expired/defaults":{"get":{"tags":["ExpiredController"],"summary":"Get default expiration settings","description":"Return default times used for inbox expiration","operationId":"getExpirationDefaults","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ExpirationDefaults"}}}}}}},"/emails/{emailId}/urls":{"get":{"tags":["EmailController"],"summary":"Get email URLs for viewing in browser or downloading","description":"Get a list of URLs for email content as text/html or raw SMTP message for viewing the message in a browser.","operationId":"getEmailPreviewURLs","parameters":[{"name":"emailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailPreviewUrls"}}}}}}},"/emails/{emailId}/textLines":{"get":{"tags":["EmailController"],"summary":"Parse and return text from an email, stripping HTML and decoding encoded characters","description":"Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.","operationId":"getEmailTextLines","parameters":[{"name":"emailId","in":"path","description":"ID of email to fetch text for","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"decodeHtmlEntities","in":"query","description":"Decode HTML entities","required":false,"schema":{"type":"boolean"}},{"name":"lineSeparator","in":"query","description":"Line separator character","required":false,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailTextLinesResult"}}}}}}},"/emails/{emailId}/raw":{"get":{"tags":["EmailController"],"summary":"Get raw email string. Returns unparsed raw SMTP message with headers and body.","description":"Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint","operationId":"getRawEmailContents","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"text/plain":{"schema":{"type":"string"}}}}}}},"/emails/{emailId}/raw/json":{"get":{"tags":["EmailController"],"summary":"Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.","description":"Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response","operationId":"getRawEmailJson","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/RawEmailJson"}}}}}}},"/emails/{emailId}/links":{"get":{"tags":["EmailController"],"summary":"Parse and return list of links found in an email (only works for HTML content)","description":"HTML parsing uses JSoup and UNIX line separators. Searches content for href attributes","operationId":"getEmailLinks","parameters":[{"name":"emailId","in":"path","description":"ID of email to fetch text for","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailLinksResult"}}}}}}},"/emails/{emailId}/html":{"get":{"tags":["EmailController"],"summary":"Get email content as HTML. For displaying emails in browser context.","description":"Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`","operationId":"getEmailHTML","parameters":[{"name":"emailId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"decode","in":"query","required":false,"schema":{"type":"boolean","default":false}}],"responses":{"200":{"description":"OK","content":{"text/html":{"schema":{"type":"string"}}}}}}},"/emails/{emailId}/htmlQuery":{"get":{"tags":["EmailController"],"summary":"Parse and return text from an email, stripping HTML and decoding encoded characters","description":"Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors","operationId":"getEmailHTMLQuery","parameters":[{"name":"emailId","in":"path","description":"ID of email to perform HTML query on","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"htmlSelector","in":"query","description":"HTML selector to search for. Uses JQuery/JSoup/CSS style selector like '.my-div' to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/EmailTextLinesResult"}}}}}}},"/emails/{emailId}/body":{"get":{"tags":["EmailController"],"summary":"Get email body as string. Returned as `plain/text` with content type header.","description":"Returns the specified email body for a given email as a string","operationId":"downloadBody","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"text/plain":{"schema":{"type":"string"}},"text/html":{"schema":{"type":"string"}}}}}}},"/emails/{emailId}/body-bytes":{"get":{"tags":["EmailController"],"summary":"Get email body in bytes. Returned as `octet-stream` with content type header.","description":"Returns the specified email body for a given email as a stream / array of bytes.","operationId":"downloadBodyBytes","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"default":{"description":"default response","content":{"application/octet-stream":{"schema":{"type":"string","format":"byte"}}}}}}},"/emails/{emailId}/attachments":{"get":{"tags":["EmailController"],"summary":"Get all email attachment metadata. Metadata includes name and size of attachments.","description":"Returns an array of attachment metadata such as name and content-type for a given email if present.","operationId":"getEmailAttachments","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"$ref":"#/components/schemas/AttachmentMetaData"}}}}}}}},"/emails/{emailId}/attachments/{attachmentId}":{"get":{"tags":["EmailController"],"summary":"Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.","description":"Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.","operationId":"downloadAttachment","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}},{"name":"apiKey","in":"query","description":"Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.","required":false,"schema":{"type":"string"}}],"responses":{"default":{"description":"default response","content":{"application/octet-stream":{"schema":{"type":"string","format":"byte"}}}}}}},"/emails/{emailId}/attachments/{attachmentId}/metadata":{"get":{"tags":["EmailController"],"summary":"Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.","description":"Returns the metadata such as name and content-type for a given attachment and email.","operationId":"getAttachmentMetaData","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AttachmentMetaData"}}}}}}},"/emails/{emailId}/attachments/{attachmentId}/base64":{"get":{"tags":["EmailController"],"summary":"Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.","description":"Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.","operationId":"downloadAttachmentBase64","parameters":[{"name":"emailId","in":"path","description":"ID of email","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DownloadAttachmentDto"}}}}}}},"/emails/unreadCount":{"get":{"tags":["EmailController"],"summary":"Get unread email count","description":"Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response","operationId":"getUnreadEmailCount","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/UnreadCount"}}}}}}},"/emails/organization":{"get":{"tags":["EmailController"],"summary":"Get all organization emails. List team or shared test email accounts","description":"By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages","operationId":"getOrganizationEmailsPaginated","parameters":[{"name":"inboxId","in":"query","description":"Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.","required":false,"schema":{"type":"array","items":{"type":"string","format":"uuid"}}},{"name":"page","in":"query","description":"Optional page index in email list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results","required":false,"schema":{"maximum":100,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"unreadOnly","in":"query","description":"Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly","required":false,"schema":{"type":"boolean","default":false}},{"name":"searchFilter","in":"query","description":"Optional search filter search filter for emails.","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Optional filter emails received after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter emails received before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageEmailProjection"}}}}}}},"/emails/latest":{"get":{"tags":["EmailController"],"summary":"Get latest email in all inboxes. Most recently received.","description":"Get the newest email in all inboxes or in a passed set of inbox IDs","operationId":"getLatestEmail","parameters":[{"name":"inboxIds","in":"query","description":"Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes","required":false,"schema":{"type":"array","items":{"type":"string","format":"uuid"}}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/emails/latestIn":{"get":{"tags":["EmailController"],"summary":"Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.","description":"Get the newest email in all inboxes or in a passed set of inbox IDs","operationId":"getLatestEmailInInbox_1","parameters":[{"name":"inboxId","in":"query","description":"ID of the inbox you want to get the latest email from","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/Email"}}}}}}},"/emails/gravatarFor":{"get":{"tags":["EmailController"],"description":"Get gravatar url for email address","operationId":"getGravatarUrlForEmailAddress","parameters":[{"name":"emailAddress","in":"query","required":true,"schema":{"type":"string"}},{"name":"size","in":"query","required":false,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/GravatarUrl"}}}}}}},"/emails/emails/count":{"get":{"tags":["EmailController"],"summary":"Get email count","operationId":"getEmailCount","responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/CountDto"}}}}}}},"/email-verification/validation-requests":{"get":{"tags":["EmailVerificationController"],"summary":"Validate a list of email addresses. Per unit billing. See your plan for pricing.","operationId":"getValidationRequests","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"maximum":9223372036854775807,"minimum":0,"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size for paginated result list.","required":false,"schema":{"maximum":100,"minimum":1,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"DESC","enum":["ASC","DESC"]}},{"name":"searchFilter","in":"query","description":"Optional search filter","required":false,"schema":{"type":"string"}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"isValid","in":"query","description":"Filter where email is valid is true or false","required":false,"schema":{"type":"boolean"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageEmailValidationRequest"}}}}}}},"/contacts/{contactId}":{"get":{"tags":["ContactController"],"summary":"Get contact","operationId":"getContact","parameters":[{"name":"contactId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/ContactDto"}}}}}},"delete":{"tags":["ContactController"],"summary":"Delete contact","operationId":"deleteContact","parameters":[{"name":"contactId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/contacts/{contactId}/download":{"get":{"tags":["ContactController"],"summary":"Get contact vCard vcf file","operationId":"getContactVCard","parameters":[{"name":"contactId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"type":"array","items":{"type":"string","format":"byte"}}}}}}}},"/contacts/paginated":{"get":{"tags":["ContactController"],"summary":"Get all contacts","operationId":"getAllContacts","parameters":[{"name":"page","in":"query","description":"Optional page index in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageContactProjection"}}}}}}},"/bounce/recipients":{"get":{"tags":["BounceController"],"summary":"Get paginated list of bounced recipients.","description":"Bounced recipients are email addresses that you have sent emails to that did not accept the sent email. Once a recipient is bounced you cannot send emails to that address.","operationId":"getBouncedRecipients","parameters":[{"name":"page","in":"query","description":"Optional page index ","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size ","required":false,"schema":{"maximum":100,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageBouncedRecipients"}}}}}}},"/bounce/recipients/{id}":{"get":{"tags":["BounceController"],"summary":"Get a bounced email.","description":"Bounced emails are email you have sent that were rejected by a recipient","operationId":"getBouncedRecipient","parameters":[{"name":"id","in":"path","description":"ID of the bounced recipient","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/BouncedRecipientDto"}}}}}}},"/bounce/emails":{"get":{"tags":["BounceController"],"summary":"Get paginated list of bounced emails.","description":"Bounced emails are email you have sent that were rejected by a recipient","operationId":"getBouncedEmails","parameters":[{"name":"page","in":"query","description":"Optional page index","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size ","required":false,"schema":{"maximum":100,"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Filter by created at after the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Filter by created at before the given timestamp","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageBouncedEmail"}}}}}}},"/bounce/emails/{id}":{"get":{"tags":["BounceController"],"summary":"Get a bounced email.","description":"Bounced emails are email you have sent that were rejected by a recipient","operationId":"getBouncedEmail","parameters":[{"name":"id","in":"path","description":"ID of the bounced email to fetch","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/BouncedEmailDto"}}}}}}},"/attachments/{attachmentId}":{"get":{"tags":["AttachmentController"],"summary":"Get an attachment entity","operationId":"getAttachment","parameters":[{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AttachmentEntity"}}}}}},"delete":{"tags":["AttachmentController"],"summary":"Delete an attachment","operationId":"deleteAttachment","parameters":[{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"204":{"description":"No Content"}}}},"/attachments/{attachmentId}/metadata":{"get":{"tags":["AttachmentController"],"summary":"Get email attachment metadata information","description":"Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.","operationId":"getAttachmentInfo","parameters":[{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/AttachmentMetaData"}}}}}}},"/attachments/{attachmentId}/bytes":{"get":{"tags":["AttachmentController"],"summary":"Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.","description":"Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.","operationId":"downloadAttachmentAsBytes","parameters":[{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"default":{"description":"default response","content":{"application/octet-stream":{"schema":{"type":"string","format":"byte"}}}}}}},"/attachments/{attachmentId}/base64":{"get":{"tags":["AttachmentController"],"summary":"Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.","description":"Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.","operationId":"downloadAttachmentAsBase64Encoded","parameters":[{"name":"attachmentId","in":"path","description":"ID of attachment","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/DownloadAttachmentDto"}}}}}}},"/aliases/{aliasId}/threads":{"get":{"tags":["AliasController"],"summary":"Get threads created for an alias","description":"Returns threads created for an email alias in paginated form","operationId":"getAliasThreads","parameters":[{"name":"aliasId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"page","in":"query","description":"Optional page index in thread list pagination","required":false,"schema":{"type":"integer","format":"int32","default":0}},{"name":"size","in":"query","description":"Optional page size in thread list pagination","required":false,"schema":{"type":"integer","format":"int32","default":20}},{"name":"sort","in":"query","description":"Optional createdAt sort direction ASC or DESC","required":false,"schema":{"type":"string","default":"ASC","enum":["ASC","DESC"]}},{"name":"since","in":"query","description":"Optional filter by sent after given date time","required":false,"schema":{"type":"string","format":"date-time"}},{"name":"before","in":"query","description":"Optional filter by sent before given date time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/PageThreadProjection"}}}}}}},"/webhooks":{"delete":{"tags":["WebhookController"],"summary":"Delete all webhooks","operationId":"deleteAllWebhooks","responses":{"204":{"description":"No Content"}}}},"/inboxes/{inboxId}/webhooks/{webhookId}":{"delete":{"tags":["WebhookController"],"summary":"Delete and disable a Webhook for an Inbox","operationId":"deleteWebhook","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}},{"name":"webhookId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/inboxes/{inboxId}/deleteAllInboxEmails":{"delete":{"tags":["InboxController"],"summary":"Delete all emails in a given inboxes.","description":"Deletes all emails in an inbox. Be careful as emails cannot be recovered","operationId":"deleteAllInboxEmails","parameters":[{"name":"inboxId","in":"path","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/inboxes/expired":{"delete":{"tags":["InboxController"],"summary":"Remove expired inboxes","description":"Remove any expired inboxes for your account (instead of waiting for scheduled removal on server)","operationId":"flushExpired","parameters":[{"name":"before","in":"query","description":"Optional expired at before flag to flush expired inboxes that have expired before the given time","required":false,"schema":{"type":"string","format":"date-time"}}],"responses":{"200":{"description":"OK","content":{"*/*":{"schema":{"$ref":"#/components/schemas/FlushExpiredInboxesResult"}}}}}}},"/emptyInbox":{"delete":{"tags":["CommonActionsController"],"summary":"Delete all emails in an inbox","description":"Deletes all emails","operationId":"emptyInbox","parameters":[{"name":"inboxId","in":"query","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}},"/deleteEmailAddress":{"delete":{"tags":["CommonActionsController"],"summary":"Delete inbox email address by inbox id","description":"Deletes inbox email address","operationId":"deleteEmailAddress","parameters":[{"name":"inboxId","in":"query","required":true,"schema":{"type":"string","format":"uuid"}}],"responses":{"204":{"description":"No Content"}}}}},"components":{"schemas":{"CreateTemplateOptions":{"required":["content","name"],"type":"object","properties":{"name":{"type":"string"},"content":{"type":"string"}}},"TemplateDto":{"required":["content","createdAt","id","name","variables"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"name":{"type":"string"},"variables":{"type":"array","items":{"$ref":"#/components/schemas/TemplateVariable"}},"content":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}}},"TemplateVariable":{"required":["name","variableType"],"type":"object","properties":{"name":{"type":"string"},"variableType":{"type":"string","enum":["STRING"]}}},"InboxRulesetTestOptions":{"required":["testTarget"],"type":"object","properties":{"testTarget":{"type":"string"}}},"InboxRulesetTestResult":{"required":["matches","rulesetMatches"],"type":"object","properties":{"rulesetMatches":{"type":"object","additionalProperties":{"type":"boolean","description":"Map of inbox ruleset ID to boolean of if target matches"},"description":"Map of inbox ruleset ID to boolean of if target matches"},"matches":{"type":"boolean"}}},"SetInboxFavouritedOptions":{"required":["state"],"type":"object","properties":{"state":{"type":"boolean","description":"Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering"}},"description":"Options for setting inbox favourite state"},"InboxDto":{"title":"Inbox","required":["createdAt","emailAddress","favourite","id","readOnly"],"type":"object","properties":{"id":{"type":"string","description":"ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods `waitForLatestEmail` and `getEmails` methods respectively. Inboxes can be used with aliases to forward emails automatically.","format":"uuid"},"userId":{"type":"string","description":"ID of user that inbox belongs to","format":"uuid"},"createdAt":{"type":"string","description":"When the inbox was created. Time stamps are in ISO DateTime Format `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` e.g. `2000-10-31T01:30:00.000-05:00`.","format":"date-time"},"name":{"type":"string","description":"Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search"},"description":{"type":"string","description":"Description of an inbox for labelling and searching purposes"},"emailAddress":{"type":"string","description":"The inbox's email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so `+123` additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID."},"expiresAt":{"type":"string","description":"Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email."},"favourite":{"type":"boolean","description":"Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering"},"tags":{"type":"array","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","items":{"type":"string","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI."}},"inboxType":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]},"readOnly":{"type":"boolean","description":"Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes."}},"description":"Representation of a MailSlurp inbox. An inbox has an ID and a real email address. Emails can be sent to or from this email address. Inboxes are either `SMTP` or `HTTP` mailboxes. The default, `HTTP` inboxes, use AWS SES to process emails and are best suited as test email accounts and do not support IMAP or POP3. `SMTP` inboxes use a custom mail server at `mx.mailslurp.com` and support SMTP login, IMAP and POP3. Use the `EmailController` or the `InboxController` methods to send and receive emails and attachments. Inboxes may have a description, name, and tags for display purposes. You can also favourite an inbox for easier searching."},"UpdateGroupContacts":{"required":["contactIds"],"type":"object","properties":{"contactIds":{"type":"array","items":{"type":"string","format":"uuid"}}}},"ContactDto":{"required":["createdAt","emailAddresses","id","tags"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"groupId":{"type":"string","format":"uuid"},"firstName":{"type":"string"},"lastName":{"type":"string"},"company":{"type":"string"},"emailAddresses":{"type":"array","items":{"type":"string"}},"primaryEmailAddress":{"type":"string"},"tags":{"type":"array","items":{"type":"string"}},"metaData":{"$ref":"#/components/schemas/JsonNode"},"optOut":{"type":"boolean"},"createdAt":{"type":"string","format":"date-time"}}},"GroupContactsDto":{"required":["contacts","group"],"type":"object","properties":{"group":{"$ref":"#/components/schemas/GroupDto"},"contacts":{"type":"array","items":{"$ref":"#/components/schemas/ContactDto"}}}},"GroupDto":{"required":["createdAt","id","name"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"name":{"type":"string"},"description":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}}},"JsonNode":{"type":"object"},"InboxForwarderTestOptions":{"required":["testValue"],"type":"object","properties":{"testValue":{"type":"string"}}},"InboxForwarderTestResult":{"required":["doesMatch","matches"],"type":"object","properties":{"matches":{"type":"object","additionalProperties":{"type":"boolean"}},"doesMatch":{"type":"boolean"}}},"ReplyToEmailOptions":{"required":["body","isHTML"],"type":"object","properties":{"body":{"type":"string","description":"Body of the reply email you want to send"},"isHTML":{"type":"boolean","description":"Is the reply HTML"},"from":{"type":"string","description":"The from header that should be used. Optional"},"replyTo":{"type":"string","description":"The replyTo header that should be used. Optional"},"charset":{"type":"string","description":"The charset that your message should be sent with. Optional. Default is UTF-8"},"attachments":{"type":"array","description":"List of uploaded attachments to send with the reply. Optional.","items":{"type":"string","description":"List of uploaded attachments to send with the reply. Optional."}},"templateVariables":{"type":"object","additionalProperties":{"type":"object","description":"Template variables if using a template"},"description":"Template variables if using a template"},"template":{"type":"string","description":"Template ID to use instead of body. Will use template variable map to fill defined variable slots.","format":"uuid"},"sendStrategy":{"type":"string","description":"How an email should be sent based on its recipients","enum":["SINGLE_MESSAGE"]},"useInboxName":{"type":"boolean","description":"Optionally use inbox name as display name for sender email address"}},"description":"Options for replying to email with API"},"SentEmailDto":{"required":["id","inboxId","sentAt","userId"],"type":"object","properties":{"id":{"type":"string","description":"ID of sent email","format":"uuid"},"userId":{"type":"string","description":"User ID","format":"uuid"},"inboxId":{"type":"string","description":"Inbox ID email was sent from","format":"uuid"},"to":{"type":"array","description":"Recipients email was sent to","items":{"type":"string","description":"Recipients email was sent to"}},"from":{"type":"string"},"replyTo":{"type":"string"},"cc":{"type":"array","items":{"type":"string"}},"bcc":{"type":"array","items":{"type":"string"}},"attachments":{"type":"array","description":"Array of IDs of attachments that were sent with this email","items":{"type":"string","description":"Array of IDs of attachments that were sent with this email"}},"subject":{"type":"string"},"bodyMD5Hash":{"type":"string","description":"MD5 Hash"},"body":{"type":"string"},"charset":{"type":"string"},"isHTML":{"type":"boolean"},"sentAt":{"type":"string","format":"date-time"},"pixelIds":{"type":"array","items":{"type":"string","format":"uuid"}},"messageId":{"type":"string"}},"description":"Sent email details"},"UpdateDomainOptions":{"type":"object","properties":{"catchAllInboxId":{"type":"string","format":"uuid"}},"description":"Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it. Domains will not functionally currently until the domain has been verified. See https://www.mailslurp.com/guides/custom-domains for help."},"DomainDto":{"required":["createdAt","dkimTokens","domain","domainNameRecords","domainType","id","isVerified","updatedAt","userId","verificationToken"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"domain":{"type":"string","description":"Custom domain name"},"verificationToken":{"type":"string","description":"Verification tokens"},"dkimTokens":{"type":"array","description":"Unique token DKIM tokens","items":{"type":"string","description":"Unique token DKIM tokens"}},"isVerified":{"type":"boolean","description":"Whether domain has been verified or not. If the domain is not verified after 72 hours there is most likely an issue with the domains DNS records."},"domainNameRecords":{"type":"array","description":"List of DNS domain name records (C, MX, TXT) etc that you must add to the DNS server associated with your domain provider.","items":{"$ref":"#/components/schemas/DomainNameRecord"}},"catchAllInboxId":{"type":"string","description":"The optional catch all inbox that will receive emails sent to the domain that cannot be matched.","format":"uuid"},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"},"domainType":{"type":"string","description":"Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.","enum":["HTTP_INBOX","SMTP_DOMAIN"]}},"description":"Domain plus verification records and status"},"DomainNameRecord":{"required":["name","recordEntries","recordType","ttl"],"type":"object","properties":{"recordType":{"type":"string","description":"Domain Name Server Record Types","enum":["A","NS","MD","MF","CNAME","SOA","MB","MG","MR","NULL","WKS","PTR","HINFO","MINFO","MX","TXT","RP","AFSDB","X25","ISDN","RT","NSAP","NSAP_PTR","SIG","KEY","PX","GPOS","AAAA","LOC","NXT","EID","NIMLOC","SRV","ATMA","NAPTR","KX","CERT","A6","DNAME","SINK","OPT","APL","DS","SSHFP","IPSECKEY","RRSIG","NSEC","DNSKEY","DHCID","NSEC3","NSEC3PARAM","TLSA","SMIMEA","HIP","NINFO","RKEY","TALINK","CDS","CDNSKEY","OPENPGPKEY","CSYNC","ZONEMD","SVCB","HTTPS","SPF","UINFO","UID","GID","UNSPEC","NID","L32","L64","LP","EUI48","EUI64","TKEY","TSIG","IXFR","AXFR","MAILB","MAILA","ANY","URI","CAA","AVC","DOA","AMTRELAY","TA","DLV"]},"name":{"type":"string"},"recordEntries":{"type":"array","items":{"type":"string"}},"ttl":{"type":"integer","format":"int64"}},"description":"DNS Record required for verification of a domain. Record vary depending on domain type."},"UpdateAliasOptions":{"type":"object","properties":{"name":{"type":"string","description":"Optional name for alias"}},"description":"Update an email alias"},"AliasDto":{"required":["emailAddress","id","inboxId","isVerified","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"emailAddress":{"type":"string","description":"The alias's email address for receiving email"},"maskedEmailAddress":{"type":"string","description":"The underlying email address that is hidden and will received forwarded email"},"userId":{"type":"string","format":"uuid"},"inboxId":{"type":"string","description":"Inbox that is associated with the alias","format":"uuid"},"name":{"type":"string"},"useThreads":{"type":"boolean","description":"If alias will generate response threads or not when email are received by it"},"isVerified":{"type":"boolean","description":"Has the alias been verified. You must verify an alias if the masked email address has not yet been verified by your account"},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"}},"description":"Email alias representation"},"ReplyToAliasEmailOptions":{"required":["body","isHTML"],"type":"object","properties":{"body":{"type":"string","description":"Body of the reply email you want to send"},"isHTML":{"type":"boolean","description":"Is the reply HTML"},"charset":{"type":"string","description":"The charset that your message should be sent with. Optional. Default is UTF-8"},"attachments":{"type":"array","description":"List of uploaded attachments to send with the reply. Optional.","items":{"type":"string","description":"List of uploaded attachments to send with the reply. Optional."}},"templateVariables":{"type":"object","additionalProperties":{"type":"object","description":"Template variables if using a template"},"description":"Template variables if using a template"},"template":{"type":"string","description":"Template ID to use instead of body. Will use template variable map to fill defined variable slots.","format":"uuid"},"sendStrategy":{"type":"string","description":"How an email should be sent based on its recipients","enum":["SINGLE_MESSAGE"]},"useInboxName":{"type":"boolean","description":"Optionally use inbox name as display name for sender email address"}},"description":"Options for replying to an alias email using the alias inbox"},"WebhookTestRequest":{"required":["headers","method","url"],"type":"object","properties":{"url":{"type":"string"},"method":{"type":"string","enum":["GET","HEAD","POST","PUT","PATCH","DELETE","OPTIONS","TRACE"]},"headers":{"type":"object","additionalProperties":{"type":"string"}},"payload":{"type":"string"}}},"WebhookTestResponse":{"type":"object","properties":{"statusCode":{"type":"integer","format":"int32"},"message":{"type":"string"}}},"WebhookTestResult":{"required":["request","response"],"type":"object","properties":{"message":{"type":"string"},"response":{"$ref":"#/components/schemas/WebhookTestResponse"},"request":{"$ref":"#/components/schemas/WebhookTestRequest"}},"description":"Results of testing a webhook"},"JSONSchemaDto":{"required":["value"],"type":"object","properties":{"value":{"type":"string"}}},"AbstractWebhookPayload":{"required":["eventName","messageId","webhookId"],"type":"object","properties":{"eventName":{"type":"string","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"webhookId":{"type":"string","format":"uuid"},"messageId":{"type":"string"},"webhookName":{"type":"string"}},"description":"Abstract webhook payload. Use the correct payload type for your webhook event type in order to access all the specific properties for that event. See the `NEW_EMAIL`,`NEW_CONTACT`, `NEW_ATTACHMENT` and `EMAIL_OPENED` payloads for the properties available for those events."},"WebhookRedriveResult":{"required":["success","webhookResultId"],"type":"object","properties":{"webhookResultId":{"type":"string","format":"uuid"},"success":{"type":"boolean"},"message":{"type":"string"}}},"MatchOption":{"required":["field","should","value"],"type":"object","properties":{"field":{"title":"MatchField","type":"string","description":"Fields of an email object that can be used to filter results","enum":["SUBJECT","TO","BCC","CC","FROM"]},"should":{"title":"MatchShould","type":"string","description":"How the value of the email field specified should be compared to the value given in the match options.","enum":["CONTAIN","EQUAL"]},"value":{"type":"string","description":"The value you wish to compare with the value of the field specified using the `should` value passed. For example `BODY` should `CONTAIN` a value passed."}},"description":"Options for matching emails in an inbox. Each match option object contains a `field`, `should` and `value` property. Together they form logical conditions such as `SUBJECT` should `CONTAIN` value."},"WaitForConditions":{"required":["inboxId","timeout"],"type":"object","properties":{"inboxId":{"type":"string","description":"ID of inbox to search within and apply conditions to. Essentially filtering the emails found to give a count.","format":"uuid"},"count":{"type":"integer","description":"Number of results that should match conditions. Either exactly or at least this amount based on the `countType`. If count condition is not met and the timeout has not been reached the `waitFor` method will retry the operation.","format":"int32"},"delayTimeout":{"type":"integer","description":"Max time in milliseconds to wait between retries if a `timeout` is specified.","format":"int64"},"timeout":{"type":"integer","description":"Max time in milliseconds to retry the `waitFor` operation until conditions are met.","format":"int64"},"unreadOnly":{"type":"boolean","description":"Apply conditions only to **unread** emails. All emails begin with `read=false`. An email is marked `read=true` when an `EmailDto` representation of it has been returned to the user at least once. For example you have called `getEmail` or `waitForLatestEmail` etc., or you have viewed the email in the dashboard."},"countType":{"title":"CountType","type":"string","description":"How result size should be compared with the expected size. Exactly or at-least matching result?","enum":["EXACTLY","ATLEAST"]},"matches":{"type":"array","description":"Conditions that should be matched for an email to qualify for results. Each condition will be applied in order to each email within an inbox to filter a result list of matching emails you are waiting for.","items":{"$ref":"#/components/schemas/MatchOption"}},"sortDirection":{"type":"string","description":"Direction to sort matching emails by created time","enum":["ASC","DESC"]},"since":{"type":"string","description":"ISO Date Time earliest time of email to consider. Filter for matching emails that were received after this date","format":"date-time"},"before":{"type":"string","description":"ISO Date Time latest time of email to consider. Filter for matching emails that were received before this date","format":"date-time"}},"description":"Conditions to apply to emails that you are waiting for"},"EmailPreview":{"required":["createdAt","id","to"],"type":"object","properties":{"id":{"type":"string","description":"ID of the email entity","format":"uuid"},"subject":{"type":"string","description":"The subject line of the email message as specified by SMTP subject header"},"to":{"type":"array","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names."}},"from":{"type":"string","description":"Who the email was sent from. An email address - see fromName for the sender name."},"bcc":{"type":"array","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names."}},"cc":{"type":"array","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names."}},"createdAt":{"type":"string","description":"When was the email received by MailSlurp","format":"date-time"},"read":{"type":"boolean","description":"Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks."},"attachments":{"type":"array","description":"List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.","items":{"type":"string","description":"List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension."}}},"description":"Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID."},"ConditionOption":{"required":["condition","value"],"type":"object","properties":{"condition":{"title":"ConditionField","type":"string","description":"Condition of an email object that can be used to filter results","enum":["HAS_ATTACHMENTS"]},"value":{"title":"ConditionValue","type":"string","description":"Expected condition value","enum":["TRUE","FALSE"]}},"description":"Options for matching emails in an inbox based on a condition such as `HAS_ATTACHMENTS=TRUE`"},"MatchOptions":{"type":"object","properties":{"matches":{"type":"array","description":"Zero or more match options such as `{ field: 'SUBJECT', should: 'CONTAIN', value: 'Welcome' }`. Options are additive so if one does not match the email is excluded from results","items":{"$ref":"#/components/schemas/MatchOption"}},"conditions":{"type":"array","description":"Zero or more conditions such as `{ condition: 'HAS_ATTACHMENTS', value: 'TRUE' }`. Note the values are the strings `TRUE|FALSE` not booleans.","items":{"$ref":"#/components/schemas/ConditionOption"}}},"description":"Optional filter for matching emails based on fields. For instance filter results to only include emails whose `SUBJECT` value does `CONTAIN` given match value. An example payload would be `{ matches: [{ field: 'SUBJECT', should: 'CONTAIN', value: 'Welcome' }] }`. You can also pass conditions such as `HAS_ATTACHMENT`. If you wish to extract regex matches inside the email content see the `getEmailContentMatch` method in the EmailController."},"Email":{"required":["createdAt","id","inboxId","read","teamAccess","to","updatedAt","userId"],"type":"object","properties":{"id":{"type":"string","description":"ID of the email entity","format":"uuid"},"userId":{"type":"string","description":"ID of user that email belongs to","format":"uuid"},"inboxId":{"type":"string","description":"ID of the inbox that received the email","format":"uuid"},"to":{"type":"array","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names."}},"from":{"type":"string","description":"Who the email was sent from. An email address - see fromName for the sender name."},"sender":{"$ref":"#/components/schemas/Sender"},"recipients":{"$ref":"#/components/schemas/EmailRecipients"},"replyTo":{"type":"string","description":"The `replyTo` field on the received email message"},"cc":{"type":"array","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names."}},"bcc":{"type":"array","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names."}},"headers":{"type":"object","additionalProperties":{"type":"string","description":"Collection of SMTP headers attached to email"},"description":"Collection of SMTP headers attached to email"},"attachments":{"type":"array","description":"List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.","items":{"type":"string","description":"List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension."}},"subject":{"type":"string","description":"The subject line of the email message as specified by SMTP subject header"},"body":{"type":"string","description":"The body of the email message as text parsed from the SMTP message body (does not include attachments). Fetch the raw content to access the SMTP message and use the attachments property to access attachments. The body is stored separately to the email entity so the body is not returned in paginated results only in full single email or wait requests."},"bodyExcerpt":{"type":"string","description":"An excerpt of the body of the email message for quick preview ."},"bodyMD5Hash":{"type":"string","description":"A hash signature of the email message using MD5. Useful for comparing emails without fetching full body."},"isHTML":{"type":"boolean","description":"Is the email body content type HTML?"},"charset":{"type":"string","description":"Detected character set of the email body such as UTF-8"},"analysis":{"$ref":"#/components/schemas/EmailAnalysis"},"createdAt":{"type":"string","description":"When was the email received by MailSlurp","format":"date-time"},"updatedAt":{"type":"string","description":"When was the email last updated","format":"date-time"},"read":{"type":"boolean","description":"Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks."},"teamAccess":{"type":"boolean","description":"Can the email be accessed by organization team members"}},"description":"Email entity (also known as EmailDto). When an SMTP email message is received by MailSlurp it is parsed. The body and attachments are written to disk and the fields such as to, from, subject etc are stored in a database. The `body` contains the email content. If you want the original SMTP message see the `getRawEmail` endpoints. The attachments can be fetched using the AttachmentController"},"EmailAnalysis":{"type":"object","properties":{"spamVerdict":{"type":"string","description":"Verdict of spam ranking analysis"},"virusVerdict":{"type":"string","description":"Verdict of virus scan analysis"},"spfVerdict":{"type":"string","description":"Verdict of Send Policy Framework record spoofing analysis"},"dkimVerdict":{"type":"string","description":"Verdict of DomainKeys Identified Mail analysis"},"dmarcVerdict":{"type":"string","description":"Verdict of Domain-based Message Authentication Reporting and Conformance analysis"}},"description":"Analysis result for email. Each verdict property is a string PASS|FAIL|GRAY or dynamic error message"},"EmailRecipients":{"type":"object","properties":{"to":{"type":"array","items":{"$ref":"#/components/schemas/Recipient"}},"cc":{"type":"array","items":{"$ref":"#/components/schemas/Recipient"}},"bcc":{"type":"array","items":{"$ref":"#/components/schemas/Recipient"}}},"description":"The `To`,`CC`,`BCC` recipients stored in object form with email address and name accessible."},"Recipient":{"required":["emailAddress","rawValue"],"type":"object","properties":{"rawValue":{"type":"string"},"emailAddress":{"type":"string"},"name":{"type":"string"}}},"Sender":{"required":["emailAddress","rawValue"],"type":"object","properties":{"rawValue":{"type":"string"},"emailAddress":{"type":"string"},"name":{"type":"string"}},"description":"Sender object containing from email address and from personal name if provided in address"},"CreateTrackingPixelOptions":{"type":"object","properties":{"name":{"type":"string"},"recipient":{"type":"string"}}},"TrackingPixelDto":{"required":["createdAt","html","id","seen","url"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"seen":{"type":"boolean"},"recipient":{"type":"string"},"html":{"type":"string"},"url":{"type":"string"},"inboxId":{"type":"string","format":"uuid"},"sentEmailId":{"type":"string","format":"uuid"},"seenAt":{"type":"string","format":"date-time"},"createdAt":{"type":"string","format":"date-time"}}},"SimpleSendEmailOptions":{"required":["to"],"type":"object","properties":{"senderId":{"type":"string","description":"ID of inbox to send from. If null an inbox will be created for sending","format":"uuid"},"to":{"type":"string","description":"Email address to send to"},"body":{"type":"string","description":"Body of the email message. Supports HTML"},"subject":{"type":"string","description":"Subject line of the email"}}},"CreateInboxRulesetOptions":{"required":["action","scope","target"],"type":"object","properties":{"scope":{"type":"string","description":"What type of emails actions to apply ruleset to. Either `SENDING_EMAILS` or `RECEIVING_EMAILS` will apply action and target to any sending or receiving of emails respectively.","enum":["RECEIVING_EMAILS","SENDING_EMAILS"]},"action":{"type":"string","description":"Action to be taken when the ruleset matches an email for the given scope. For example: `BLOCK` action with target `*` and scope `SENDING_EMAILS` blocks sending to all recipients. Note `ALLOW` takes precedent over `BLOCK`. `FILTER_REMOVE` is like block but will remove offending email addresses during a send or receive event instead of blocking the action.","enum":["BLOCK","ALLOW","FILTER_REMOVE"]},"target":{"type":"string","description":"Target to match emails with. Can be a wild-card type pattern or a valid email address. For instance `*@gmail.com` matches all gmail addresses while `test@gmail.com` matches one address exactly. The target is applied to every recipient field email address when `SENDING_EMAILS` is the scope and is applied to sender of email when `RECEIVING_EMAILS`."}},"description":"Options for creating inbox rulesets. Inbox rulesets can be used to block, allow, filter, or forward emails when sending or receiving using the inbox."},"InboxRulesetDto":{"required":["action","createdAt","handler","id","inboxId","scope","target"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"scope":{"type":"string","enum":["RECEIVING_EMAILS","SENDING_EMAILS"]},"action":{"type":"string","enum":["BLOCK","ALLOW","FILTER_REMOVE"]},"target":{"type":"string"},"handler":{"type":"string","enum":["EXCEPTION"]},"createdAt":{"type":"string","format":"date-time"}}},"VerifyEmailAddressOptions":{"required":["emailAddress"],"type":"object","properties":{"mailServerDomain":{"type":"string"},"emailAddress":{"type":"string"},"senderEmailAddress":{"type":"string"},"port":{"type":"integer","format":"int32"}},"description":"Options for verifying that an email address exists at a remote mail server."},"EmailVerificationResult":{"required":["domainName","emailAddress","isValid","port"],"type":"object","properties":{"domainName":{"type":"string"},"port":{"type":"integer","format":"int32"},"emailAddress":{"type":"string"},"isValid":{"type":"boolean"},"error":{"type":"string"}},"description":"Email verification result. Valid means email address exists according to response from mail server running at the domain and port given."},"IPAddressResult":{"required":["address","hostname"],"type":"object","properties":{"address":{"type":"string"},"hostname":{"type":"string"}},"description":"IP Address look up result for a given domain / hostname"},"DescribeDomainOptions":{"required":["domain"],"type":"object","properties":{"domain":{"type":"string"}}},"DescribeMailServerDomainResult":{"required":["domain","mxRecords"],"type":"object","properties":{"mxRecords":{"type":"array","items":{"$ref":"#/components/schemas/NameServerRecord"}},"domain":{"type":"string"},"message":{"type":"string"}},"description":"Name Server lookup result"},"NameServerRecord":{"required":["priority","raw","recordType","value"],"type":"object","properties":{"raw":{"type":"string"},"recordType":{"type":"string"},"priority":{"type":"string"},"value":{"type":"string"}},"description":"Name Server Record"},"DNSLookupOptions":{"required":["hostname","omitFinalDNSDot","recordTypes"],"type":"object","properties":{"hostname":{"type":"string","description":"List of record types you wish to query such as MX, DNS, TXT, NS, A etc."},"recordTypes":{"type":"array","description":"List of record types you wish to query such as MX, DNS, TXT, NS, A etc.","items":{"type":"string","description":"Domain Name Server Record Types","enum":["A","NS","MD","MF","CNAME","SOA","MB","MG","MR","NULL","WKS","PTR","HINFO","MINFO","MX","TXT","RP","AFSDB","X25","ISDN","RT","NSAP","NSAP_PTR","SIG","KEY","PX","GPOS","AAAA","LOC","NXT","EID","NIMLOC","SRV","ATMA","NAPTR","KX","CERT","A6","DNAME","SINK","OPT","APL","DS","SSHFP","IPSECKEY","RRSIG","NSEC","DNSKEY","DHCID","NSEC3","NSEC3PARAM","TLSA","SMIMEA","HIP","NINFO","RKEY","TALINK","CDS","CDNSKEY","OPENPGPKEY","CSYNC","ZONEMD","SVCB","HTTPS","SPF","UINFO","UID","GID","UNSPEC","NID","L32","L64","LP","EUI48","EUI64","TKEY","TSIG","IXFR","AXFR","MAILB","MAILA","ANY","URI","CAA","AVC","DOA","AMTRELAY","TA","DLV"]}},"omitFinalDNSDot":{"type":"boolean","description":"Optionally control whether to omit the final dot in full DNS name values."}},"description":"Options for DNS query. "},"DNSLookupResult":{"required":["name","recordEntries","recordType","ttl"],"type":"object","properties":{"recordType":{"type":"string","description":"Domain Name Server Record Types","enum":["A","NS","MD","MF","CNAME","SOA","MB","MG","MR","NULL","WKS","PTR","HINFO","MINFO","MX","TXT","RP","AFSDB","X25","ISDN","RT","NSAP","NSAP_PTR","SIG","KEY","PX","GPOS","AAAA","LOC","NXT","EID","NIMLOC","SRV","ATMA","NAPTR","KX","CERT","A6","DNAME","SINK","OPT","APL","DS","SSHFP","IPSECKEY","RRSIG","NSEC","DNSKEY","DHCID","NSEC3","NSEC3PARAM","TLSA","SMIMEA","HIP","NINFO","RKEY","TALINK","CDS","CDNSKEY","OPENPGPKEY","CSYNC","ZONEMD","SVCB","HTTPS","SPF","UINFO","UID","GID","UNSPEC","NID","L32","L64","LP","EUI48","EUI64","TKEY","TSIG","IXFR","AXFR","MAILB","MAILA","ANY","URI","CAA","AVC","DOA","AMTRELAY","TA","DLV"]},"ttl":{"type":"integer","format":"int64"},"recordEntries":{"type":"array","items":{"type":"string"}},"name":{"type":"string"}},"description":"DNS lookup result. Includes record type, time to live, raw response, and name value for the name server response."},"DNSLookupResults":{"required":["results"],"type":"object","properties":{"results":{"type":"array","items":{"$ref":"#/components/schemas/DNSLookupResult"}}},"description":"Results of query on domain name servers"},"GetOrCreateSamlUserOptions":{"required":["issuer","nameId"],"type":"object","properties":{"issuer":{"type":"string"},"nameId":{"type":"string"},"nameIdFormat":{"type":"string"}}},"UserDto":{"required":["apiKey","emailAddress","emailAddressMd5","hasPassword","id","isFrozen"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"apiKey":{"type":"string"},"emailAddress":{"type":"string"},"emailAddressMd5":{"type":"string"},"created":{"type":"string","format":"date-time"},"userType":{"type":"string","enum":["SOLO","CHILD_SOLO","CHILD_TEAM"]},"organization":{"type":"string","description":"Does user belong to an organization","format":"uuid"},"verified":{"type":"string","description":"Has user accepted an organization invite","enum":["VERIFIED","PENDING"]},"hasPassword":{"type":"boolean"},"isFrozen":{"type":"boolean"},"addNewContacts":{"type":"boolean"},"ssoProvider":{"type":"string"},"customerId":{"type":"string"},"hasOnboarded":{"type":"boolean"},"imapUsername":{"type":"string"},"imapPassword":{"type":"string"},"smtpUsername":{"type":"string"},"smtpPassword":{"type":"string"}},"description":"Representation a user's account"},"SendEmailOptions":{"type":"object","properties":{"toContacts":{"type":"array","description":"Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.","items":{"type":"string","description":"Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.","format":"uuid"}},"toGroup":{"type":"string","description":"Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients","format":"uuid"},"to":{"type":"array","description":"List of destination email addresses. Each email address must be RFC 5322 format. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating). Be cautious when sending emails that your recipients exist. High bounce rates (meaning a high percentage of emails cannot be delivered because an address does not exist) can result in account freezing.","items":{"type":"string","description":"List of destination email addresses. Each email address must be RFC 5322 format. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating). Be cautious when sending emails that your recipients exist. High bounce rates (meaning a high percentage of emails cannot be delivered because an address does not exist) can result in account freezing."}},"from":{"type":"string","description":"Optional from address. Email address is RFC 5322 format and may include a display name and email in angle brackets (`my@address.com` or `My inbox <my@address.com>`). If no sender is set the source inbox address will be used for this field. If you set `useInboxName` to `true` the from field will include the inbox name as a display name: `inbox_name <inbox@address.com>`. For this to work use the name field when creating an inbox. Beware of potential spam penalties when setting the from field to an address not used by the inbox. Your emails may get blocked by services if you impersonate another address. To use a custom email addresses use a custom domain. You can create domains with the DomainController. The domain must be verified in the dashboard before it can be used."},"cc":{"type":"array","description":"Optional list of cc destination email addresses","items":{"type":"string","description":"Optional list of cc destination email addresses"}},"bcc":{"type":"array","description":"Optional list of bcc destination email addresses","items":{"type":"string","description":"Optional list of bcc destination email addresses"}},"subject":{"type":"string","description":"Optional email subject line"},"replyTo":{"type":"string","description":"Optional replyTo header"},"body":{"type":"string","description":"Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body."},"html":{"type":"boolean","description":"Optional HTML flag to indicate that contents is HTML. Set's a `content-type: text/html` for email. (Deprecated: use `isHTML` instead.)"},"isHTML":{"type":"boolean","description":"Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients"},"charset":{"type":"string","description":"Optional charset"},"attachments":{"type":"array","description":"Optional list of attachment IDs to send with this email. You must first upload each attachment separately via method call or dashboard in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded. There are several ways to upload that support `multi-part form`, `base64 file encoding`, and octet stream binary uploads. See the `UploadController` for available methods. ","items":{"type":"string","description":"Optional list of attachment IDs to send with this email. You must first upload each attachment separately via method call or dashboard in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded. There are several ways to upload that support `multi-part form`, `base64 file encoding`, and octet stream binary uploads. See the `UploadController` for available methods. "}},"templateVariables":{"type":"object","additionalProperties":{"type":"object","description":"Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found."},"description":"Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found."},"template":{"type":"string","description":"Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.","format":"uuid"},"sendStrategy":{"type":"string","description":"How an email should be sent based on its recipients","enum":["SINGLE_MESSAGE"]},"useInboxName":{"type":"boolean","description":"Use name of inbox as sender email address name. Will construct RFC 5322 email address with `Inbox name <inbox@address.com>` if the inbox has a name."},"addTrackingPixel":{"type":"boolean","description":"Add tracking pixel to email"},"filterBouncedRecipients":{"type":"boolean","description":"Filter recipients to remove any bounced recipients from to, bcc, and cc before sending"},"validateEmailAddresses":{"type":"string","description":"Validate recipient email addresses before sending","enum":["VALIDATE_FILTER_REMOVE_INVALID","VALIDATE_ERROR_IF_INVALID","NO_VALIDATION"]}},"description":"Options for the email to be sent"},"BasicAuthOptions":{"required":["password","username"],"type":"object","properties":{"username":{"type":"string"},"password":{"type":"string"}},"description":"Basic Authentication options for webhooks. Will be used is present when calling webhook endpoints."},"CreateWebhookOptions":{"required":["url"],"type":"object","properties":{"url":{"type":"string","description":"Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received or an event is trigger. The payload of the submitted JSON is dependent on the webhook event type. The default `EMAIL_RECEIVED` payload is described by `https://api.mailslurp.com/schemas/webhook-payload`. The other events, `NEW_EMAIL`, `NEW_CONTACT`, and `NEW_ATTACHMENT` are described by `https://api.mailslurp.com/schemas/webhook-new-email-payload`, `https://api.mailslurp.com/schemas/webhook-new-contact-payload`,`https://api.mailslurp.com/schemas/webhook-new-attachment-payload` respectively."},"basicAuth":{"$ref":"#/components/schemas/BasicAuthOptions"},"name":{"type":"string","description":"Optional name for the webhook"},"eventName":{"type":"string","description":"Optional webhook event name. Default is `EMAIL_RECEIVED` and is triggered when an email is received by the inbox associated with the webhook. Payload differ according to the webhook event name. The other events are `NEW_EMAIL`, `NEW_CONTACT`, and `NEW_ATTACHMENT` and `EMAIL_OPENED`. `EMAIL_OPENED` requires the use of tracking pixels when sending. See the email tracking guide for more information.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]}},"description":"Options for creating a webhook. Webhooks can be attached to inboxes and MailSlurp will POST a webhook payload to the URL specified whenever the inbox receives an email. Webhooks are great for processing many inbound emails."},"WebhookDto":{"required":["basicAuth","createdAt","id","inboxId","method","payloadJsonSchema","updatedAt","url","userId"],"type":"object","properties":{"id":{"type":"string","description":"ID of the Webhook","format":"uuid"},"userId":{"type":"string","description":"User ID of the Webhook","format":"uuid"},"basicAuth":{"type":"boolean","description":"Does webhook expect basic authentication? If true it means you created this webhook with a username and password. MailSlurp will use these in the URL to authenticate itself."},"name":{"type":"string","description":"Name of the webhook"},"inboxId":{"type":"string","description":"The inbox that the Webhook will be triggered by","format":"uuid"},"url":{"type":"string","description":"URL of your server that the webhook will be sent to. The schema of the JSON that is sent is described by the payloadJsonSchema."},"method":{"type":"string","description":"HTTP method that your server endpoint must listen for","enum":["GET","HEAD","POST","PUT","PATCH","DELETE","OPTIONS","TRACE"]},"payloadJsonSchema":{"type":"string","description":"Deprecated. Fetch JSON Schema for webhook using the getJsonSchemaForWebhookPayload method"},"createdAt":{"type":"string","description":"When the webhook was created","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"},"eventName":{"type":"string","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]}},"description":"Representation of a webhook for an inbox. The URL specified will be using by MailSlurp whenever an email is received by the attached inbox. A webhook entity should have a URL that points to your server. Your server should accept HTTP/S POST requests and return a success 200. MailSlurp will retry your webhooks if they fail. See https://api.mailslurp.com/schemas/webhook-payload for the payload schema."},"SendSMTPEnvelopeOptions":{"required":["data","mailFrom","rcptTo"],"type":"object","properties":{"rcptTo":{"type":"array","items":{"type":"string"}},"mailFrom":{"type":"string"},"data":{"type":"string"}},"description":"Options for the email envelope"},"CreateInboxDto":{"type":"object","properties":{"emailAddress":{"type":"string","description":"A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as `123@mailslurp.com`. If you use the `useDomainPool` option when the email address is null it will generate an email address with a more varied domain ending such as `123@mailslurp.info` or `123@mailslurp.biz`. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so `SMTP` inboxes will only work with `SMTP` type domains. Avoid `SMTP` inboxes if you need to send emails as they can only receive. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID."},"name":{"type":"string","description":"Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails."},"description":{"type":"string","description":"Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with"},"useDomainPool":{"type":"boolean","description":"Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default `@mailslurp.com` email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in `@mailslurp.{world,info,xyz,...}` . This means a TLD is randomly selecting from a list of `.biz`, `.info`, `.xyz` etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of `@mailslurp.com` or custom email address provided by the emailAddress field. Note this feature is only available for `HTTP` inbox types."},"tags":{"type":"array","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","items":{"type":"string","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI."}},"expiresAt":{"type":"string","description":"Optional inbox expiration date. If null then this inbox is permanent and the emails in it won't be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd'T'HH:mm:ss.SSSXXX.","format":"date-time"},"favourite":{"type":"boolean","description":"Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering"},"expiresIn":{"type":"integer","description":"Number of milliseconds that inbox should exist for","format":"int64"},"allowTeamAccess":{"type":"boolean","description":"DEPRECATED (team access is always true). Grant team access to this inbox and the emails that belong to it for team members of your organization."},"inboxType":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]}},"description":"Options for creating an inbox. An inbox has a real email address that can send and receive emails. Inboxes can be permanent or expire at a given time. Inboxes are either `SMTP` or `HTTP` mailboxes. `SMTP` inboxes are processed by a mail server running at `mx.mailslurp.com` while `HTTP` inboxes are processed by AWS SES. Inboxes can use a custom email address (by verifying your own domain) or a randomly assigned email ending in either `mailslurp.com` or (if `useDomainPool` is enabled) ending in a similar domain such as `mailslurp.xyz` (selected at random). "},"CreateGroupOptions":{"required":["name"],"type":"object","properties":{"name":{"type":"string"},"description":{"type":"string"}}},"CreateInboxForwarderOptions":{"required":["field","forwardToRecipients","match"],"type":"object","properties":{"field":{"type":"string","description":"Field to match against to trigger inbox forwarding for inbound email","enum":["RECIPIENTS","SENDER","SUBJECT","ATTACHMENTS"]},"match":{"type":"string","description":"String or wildcard style match for field specified when evaluating forwarding rules"},"forwardToRecipients":{"type":"array","description":"Email addresses to forward an email to if it matches the field and match criteria of the forwarder","items":{"type":"string","description":"Email addresses to forward an email to if it matches the field and match criteria of the forwarder"}}},"description":"Options for creating an inbox forwarder"},"InboxForwarderDto":{"required":["createdAt","field","forwardToRecipients","id","inboxId","match"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"field":{"type":"string","enum":["RECIPIENTS","SENDER","SUBJECT","ATTACHMENTS"]},"match":{"type":"string"},"forwardToRecipients":{"type":"array","items":{"type":"string"}},"createdAt":{"type":"string","format":"date-time"}}},"ExportOptions":{"required":["outputFormat"],"type":"object","properties":{"outputFormat":{"type":"string","enum":["CSV_DEFAULT","CSV_EXCEL"]},"excludePreviouslyExported":{"type":"boolean"},"createdEarliestTime":{"type":"string","format":"date-time"},"createdOldestTime":{"type":"string","format":"date-time"},"filter":{"type":"string"},"listSeparatorToken":{"type":"string"}},"description":"Options for exporting user data"},"ExportLink":{"required":["downloadLink"],"type":"object","properties":{"downloadLink":{"type":"string"}},"description":"Export download link"},"HTMLValidationResult":{"required":["errors","isValid","warnings"],"type":"object","properties":{"isValid":{"type":"boolean","description":"Is HTML validation result valid"},"errors":{"type":"array","description":"Optional errors resulting from HTML validation","items":{"$ref":"#/components/schemas/ValidationMessage"}},"warnings":{"type":"array","description":"Optional warnings resulting from HTML validation","items":{"$ref":"#/components/schemas/ValidationMessage"}}},"description":"HTML Validation Results"},"ValidationDto":{"required":["emailId","html"],"type":"object","properties":{"emailId":{"type":"string","description":"ID of the email validated","format":"uuid"},"html":{"$ref":"#/components/schemas/HTMLValidationResult"}},"description":"Response object for email validation operation"},"ValidationMessage":{"required":["lineNumber"],"type":"object","properties":{"lineNumber":{"type":"integer","format":"int32"},"message":{"type":"string"}},"description":"Optional warnings resulting from HTML validation"},"ImapFlagOperationOptions":{"required":["flagOperation","flags"],"type":"object","properties":{"flagOperation":{"type":"string","enum":["SET_FLAGS","ADD_FLAGS","REMOVE_FLAGS"]},"flags":{"type":"array","items":{"type":"string"}}}},"ForwardEmailOptions":{"required":["to"],"type":"object","properties":{"to":{"type":"array","description":"To recipients for forwarded email","items":{"type":"string","description":"To recipients for forwarded email"}},"subject":{"type":"string","description":"Subject for forwarded email"},"cc":{"type":"array","description":"Optional cc recipients","items":{"type":"string","description":"Optional cc recipients"}},"bcc":{"type":"array","description":"Optional bcc recipients","items":{"type":"string","description":"Optional bcc recipients"}},"from":{"type":"string","description":"Optional from override"},"useInboxName":{"type":"boolean","description":"Optionally use inbox name as display name for sender email address"}},"description":"Options for forwarding an email"},"ContentMatchOptions":{"required":["pattern"],"type":"object","properties":{"pattern":{"type":"string","description":"Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns."}},"description":"Options for matching content using regex patterns based on Java Pattern syntax"},"EmailContentMatchResult":{"required":["matches","pattern"],"type":"object","properties":{"pattern":{"type":"string"},"matches":{"type":"array","items":{"type":"string"}}},"description":"Matches for the given pattern"},"ValidateEmailAddressListOptions":{"required":["emailAddressList"],"type":"object","properties":{"emailAddressList":{"maxItems":50,"minItems":1,"type":"array","items":{"type":"string"}}}},"ValidateEmailAddressListResult":{"required":["invalidEmailAddresses","resultMapEmailAddressIsValid","validEmailAddresses"],"type":"object","properties":{"validEmailAddresses":{"type":"array","items":{"type":"string"}},"invalidEmailAddresses":{"type":"array","items":{"type":"string"}},"resultMapEmailAddressIsValid":{"type":"object","additionalProperties":{"type":"boolean"}}}},"CreateDomainOptions":{"required":["domain"],"type":"object","properties":{"domain":{"type":"string","description":"The top level domain you wish to use with MailSlurp. Do not specify subdomain just the top level. So `test.com` covers all subdomains such as `mail.test.com`. Don't include a protocol such as `http://`. Once added you must complete the verification steps by adding the returned records to your domain."},"description":{"type":"string","description":"Optional description of the domain."},"createdCatchAllInbox":{"type":"boolean","description":"Whether to create a catch all inbox for the domain. Any email sent to an address using your domain that cannot be matched to an existing inbox you created with the domain will be routed to the created catch all inbox. You can access emails using the regular methods on this inbox ID."},"domainType":{"type":"string","description":"Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.","enum":["HTTP_INBOX","SMTP_DOMAIN"]}},"description":"Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it. Domains will not function correctly until the domain has been verified. See https://www.mailslurp.com/guides/custom-domains for help. Domains can be either `HTTP` or `SMTP` type. The type of domain determines which inboxes can be used with it. `SMTP` inboxes use a mail server running `mx.mailslurp.com` while `HTTP` inboxes are handled by AWS SES."},"CreateContactOptions":{"type":"object","properties":{"firstName":{"type":"string"},"lastName":{"type":"string"},"company":{"type":"string"},"emailAddresses":{"type":"array","description":"Set of email addresses belonging to the contact","items":{"type":"string","description":"Set of email addresses belonging to the contact"}},"tags":{"type":"array","description":"Tags that can be used to search and group contacts","items":{"type":"string","description":"Tags that can be used to search and group contacts"}},"metaData":{"$ref":"#/components/schemas/JsonNode"},"optOut":{"type":"boolean","description":"Has the user explicitly or implicitly opted out of being contacted? If so MailSlurp will ignore them in all actions."},"groupId":{"type":"string","description":"Group IDs that contact belongs to","format":"uuid"}}},"BulkSendEmailOptions":{"required":["inboxIds","sendEmailOptions"],"type":"object","properties":{"inboxIds":{"type":"array","description":"Inboxes to send the email from","items":{"type":"string","description":"Inboxes to send the email from","format":"uuid"}},"sendEmailOptions":{"$ref":"#/components/schemas/SendEmailOptions"}},"description":"Options for bulk sending an email from multiple addresses. See regular `sendEmail` methods for more information."},"FilterBouncedRecipientsOptions":{"required":["emailRecipients"],"type":"object","properties":{"emailRecipients":{"type":"array","items":{"type":"string"}}}},"FilterBouncedRecipientsResult":{"required":["filteredRecipients"],"type":"object","properties":{"filteredRecipients":{"type":"array","items":{"type":"string"}}}},"UploadAttachmentOptions":{"required":["base64Contents"],"type":"object","properties":{"contentType":{"title":"Content type","type":"string","description":"Optional contentType for file. For instance `application/pdf`"},"filename":{"title":"File name","type":"string","description":"Optional filename to save upload with. Will be the name that is shown in email clients"},"base64Contents":{"title":"Base 64 file contents","type":"string","description":"Base64 encoded string of file contents. Typically this means reading the bytes or string content of a file and then converting that to a base64 encoded string. For examples of how to do this see https://www.mailslurp.com/guides/base64-file-uploads/"}},"description":"Options for uploading files for attachments. When sending emails with the API that require attachments first upload each attachment. Then use the returned attachment ID in your `SendEmailOptions` when sending an email. This way you can use attachments multiple times once they have been uploaded."},"CreateAliasOptions":{"required":["emailAddress","useThreads"],"type":"object","properties":{"emailAddress":{"type":"string","description":"Email address to be hidden behind alias. Emails sent to the alias email address will be forwarded to this address. If you want to enable replies set useThreads true and the reply-to for the email will allow outbound communication via a thread."},"inboxId":{"type":"string","description":"Optional inbox ID to attach to alias. Null by default means an a new inbox will be created for the alias. Use a custom inbox to control what email address the alias uses. To use custom email addresses create a domain and an inbox, the use the inbox ID with this call. Emails received by this inbox will be forwarded to the alias email address","format":"uuid"},"name":{"type":"string","description":"Optional name for alias"},"useThreads":{"type":"boolean","description":"Enable threads options. If true emails will be sent with a unique reply-to thread address. This means you can reply to the forwarded email and it will be sent to the recipients via your alias address. That way a thread conversation is preserved."}},"description":"Create email alias options. Email aliases can be used to mask real email addresses behind an ID. You can also attach an inbox to an alias so that any email received by the inbox email address if forwarded to the alias email address."},"TestNewInboxRulesetOptions":{"required":["createInboxRulesetOptions","inboxRulesetTestOptions"],"type":"object","properties":{"inboxRulesetTestOptions":{"$ref":"#/components/schemas/InboxRulesetTestOptions"},"createInboxRulesetOptions":{"$ref":"#/components/schemas/CreateInboxRulesetOptions"}}},"UpdateInboxOptions":{"type":"object","properties":{"name":{"type":"string","description":"Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search"},"description":{"type":"string","description":"Description of an inbox for labelling and searching purposes"},"tags":{"type":"array","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","items":{"type":"string","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI."}},"expiresAt":{"type":"string","description":"Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.","format":"date-time"},"favourite":{"type":"boolean","description":"Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering"}},"description":"Options for updating inbox properties"},"TestNewInboxForwarderOptions":{"required":["createInboxForwarderOptions","inboxForwarderTestOptions"],"type":"object","properties":{"inboxForwarderTestOptions":{"$ref":"#/components/schemas/InboxForwarderTestOptions"},"createInboxForwarderOptions":{"$ref":"#/components/schemas/CreateInboxForwarderOptions"}}},"PageWebhookResult":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/WebhookResultDto"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated webhook results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"PageableObject":{"type":"object","properties":{"offset":{"type":"integer","format":"int64"},"sort":{"$ref":"#/components/schemas/Sort"},"pageNumber":{"type":"integer","format":"int32"},"pageSize":{"type":"integer","format":"int32"},"paged":{"type":"boolean"},"unpaged":{"type":"boolean"}}},"Sort":{"type":"object","properties":{"empty":{"type":"boolean"},"unsorted":{"type":"boolean"},"sorted":{"type":"boolean"}}},"WebhookResultDto":{"required":["createdAt","httpMethod","inboxId","messageId","responseTimeMillis","updatedAt","userId","webhookEvent","webhookId","webhookUrl"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"webhookId":{"type":"string","format":"uuid"},"webhookUrl":{"type":"string"},"messageId":{"type":"string"},"redriveId":{"type":"string","format":"uuid"},"httpMethod":{"type":"string","enum":["GET","HEAD","POST","PUT","PATCH","DELETE","OPTIONS","TRACE"]},"webhookEvent":{"type":"string","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"responseStatus":{"type":"integer","format":"int32"},"responseTimeMillis":{"type":"integer","format":"int64"},"responseBodyExtract":{"type":"string"},"resultType":{"type":"string","enum":["BAD_RESPONSE","EXCEPTION","SUCCESS"]},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"},"seen":{"type":"boolean"}}},"AttachmentMetaData":{"title":"Attachment meta data","required":["contentLength","contentType","id","name"],"type":"object","properties":{"name":{"title":"Name","type":"string","description":"Name of attachment if given"},"contentType":{"title":"Content type","type":"string","description":"Content type of attachment such as `image/png`"},"contentLength":{"title":"Content length","type":"integer","description":"Size of attachment in bytes","format":"int64"},"id":{"title":"ID","type":"string","description":"ID of attachment"}},"description":"Meta data associated with an attachment. Attachments are stored as byte blobs so the meta data is stored separately."},"WebhookNewEmailPayload":{"required":["attachmentMetaDatas","bcc","cc","createdAt","emailId","eventName","from","inboxId","messageId","to","webhookId"],"type":"object","properties":{"messageId":{"type":"string","description":"Idempotent message ID. Store this ID locally or in a database to prevent message duplication."},"webhookId":{"type":"string","description":"ID of webhook entity being triggered","format":"uuid"},"eventName":{"type":"string","description":"Name of the event type webhook is being triggered for.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"webhookName":{"type":"string","description":"Name of the webhook being triggered"},"inboxId":{"type":"string","description":"Id of the inbox that received an email","format":"uuid"},"emailId":{"type":"string","description":"ID of the email that was received. Use this ID for fetching the email with the `EmailController`.","format":"uuid"},"createdAt":{"type":"string","description":"Date time of event creation","format":"date-time"},"to":{"type":"array","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `To` recipient email addresses that the email was addressed to. See recipients object for names."}},"from":{"type":"string","description":"Who the email was sent from. An email address - see fromName for the sender name."},"cc":{"type":"array","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `CC` recipients email addresses that the email was addressed to. See recipients object for names."}},"bcc":{"type":"array","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names.","items":{"type":"string","description":"List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names."}},"subject":{"type":"string","description":"The subject line of the email message as specified by SMTP subject header"},"attachmentMetaDatas":{"type":"array","description":"List of attachment meta data objects if attachments present","items":{"$ref":"#/components/schemas/AttachmentMetaData"}}},"description":"NEW_EMAIL webhook payload. Sent to your webhook url endpoint via HTTP POST when an email is received by the inbox that your webhook is attached to. Use the email ID to fetch the full email body or attachments."},"WebhookNewContactPayload":{"required":["contactId","createdAt","emailAddresses","eventName","messageId","tags","webhookId"],"type":"object","properties":{"messageId":{"type":"string","description":"Idempotent message ID. Store this ID locally or in a database to prevent message duplication."},"webhookId":{"type":"string","description":"ID of webhook entity being triggered","format":"uuid"},"webhookName":{"type":"string","description":"Name of the webhook being triggered"},"eventName":{"type":"string","description":"Name of the event type webhook is being triggered for.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"contactId":{"type":"string","format":"uuid"},"groupId":{"type":"string","format":"uuid"},"firstName":{"type":"string"},"lastName":{"type":"string"},"company":{"type":"string"},"primaryEmailAddress":{"type":"string"},"emailAddresses":{"type":"array","items":{"type":"string"}},"tags":{"type":"array","items":{"type":"string"}},"metaData":{"$ref":"#/components/schemas/JsonNode"},"optOut":{"type":"boolean"},"createdAt":{"type":"string","format":"date-time"}},"description":"NEW_CONTACT webhook payload. Sent to your webhook url endpoint via HTTP POST when an email is received by the inbox that your webhook is attached to that contains a recipient that has not been saved as a contact."},"WebhookNewAttachmentPayload":{"required":["attachmentId","contentLength","contentType","eventName","messageId","name","webhookId"],"type":"object","properties":{"messageId":{"type":"string","description":"Idempotent message ID. Store this ID locally or in a database to prevent message duplication."},"webhookId":{"type":"string","description":"ID of webhook entity being triggered","format":"uuid"},"webhookName":{"type":"string","description":"Name of the webhook being triggered"},"eventName":{"type":"string","description":"Name of the event type webhook is being triggered for.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"attachmentId":{"type":"string","description":"ID of attachment. Use the `AttachmentController` to"},"name":{"type":"string","description":"Filename of the attachment if present"},"contentType":{"type":"string","description":"Content type of attachment such as 'image/png' or 'application/pdf"},"contentLength":{"type":"integer","description":"Size of attachment in bytes","format":"int64"}},"description":"NEW_ATTACHMENT webhook payload. Sent to your webhook url endpoint via HTTP POST when an email is received by the inbox that your webhook is attached to that contains an attachment. You can use the attachmentId to download the attachment."},"WebhookEmailReadPayload":{"required":["createdAt","emailId","emailIsRead","eventName","inboxId","messageId","webhookId"],"type":"object","properties":{"messageId":{"type":"string","description":"Idempotent message ID. Store this ID locally or in a database to prevent message duplication."},"webhookId":{"type":"string","description":"ID of webhook entity being triggered","format":"uuid"},"eventName":{"type":"string","description":"Name of the event type webhook is being triggered for.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"webhookName":{"type":"string","description":"Name of the webhook being triggered"},"emailId":{"type":"string","description":"ID of the email that was received. Use this ID for fetching the email with the `EmailController`.","format":"uuid"},"inboxId":{"type":"string","description":"Id of the inbox that received an email","format":"uuid"},"emailIsRead":{"type":"boolean","description":"Is the email read"},"createdAt":{"type":"string","description":"Date time of event creation","format":"date-time"}},"description":"EMAIL_READ webhook payload. Sent to your webhook url endpoint via HTTP POST when an email is read. This happens when an email is requested in full from the API or a user views the email in the dashboard."},"WebhookEmailOpenedPayload":{"required":["createdAt","eventName","inboxId","messageId","pixelId","recipient","sentEmailId","webhookId"],"type":"object","properties":{"messageId":{"type":"string","description":"Idempotent message ID. Store this ID locally or in a database to prevent message duplication."},"webhookId":{"type":"string","description":"ID of webhook entity being triggered","format":"uuid"},"eventName":{"type":"string","description":"Name of the event type webhook is being triggered for.","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"webhookName":{"type":"string","description":"Name of the webhook being triggered"},"inboxId":{"type":"string","description":"Id of the inbox that received an email","format":"uuid"},"pixelId":{"type":"string","description":"ID of the tracking pixel","format":"uuid"},"sentEmailId":{"type":"string","description":"ID of sent email","format":"uuid"},"recipient":{"type":"string","description":"Email address for the recipient of the tracking pixel"},"createdAt":{"type":"string","description":"Date time of event creation","format":"date-time"}},"description":"EMAIL_OPENED webhook payload. Sent to your webhook url endpoint via HTTP POST when an email containing a tracking pixel is opened and the pixel image is loaded by a reader."},"UnseenErrorCountDto":{"required":["count"],"type":"object","properties":{"count":{"type":"integer","format":"int64"}}},"PageWebhookProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/WebhookProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated webhook entity. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"WebhookProjection":{"required":["createdAt","id","inboxId","updatedAt","url"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"updatedAt":{"type":"string","format":"date-time"},"url":{"type":"string"},"inboxId":{"type":"string","format":"uuid"},"eventName":{"type":"string","enum":["EMAIL_RECEIVED","NEW_EMAIL","NEW_CONTACT","NEW_ATTACHMENT","EMAIL_OPENED","EMAIL_READ"]},"createdAt":{"type":"string","format":"date-time"}},"description":"Representation of a webhook"},"PageTrackingPixelProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/TrackingPixelProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated TrackingPixel results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"TrackingPixelProjection":{"required":["createdAt","id","seen","userId"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"createdAt":{"type":"string","format":"date-time"},"recipient":{"type":"string"},"seen":{"type":"boolean"},"seenAt":{"type":"string","format":"date-time"},"sentEmailId":{"type":"string","format":"uuid"}}},"TemplateProjection":{"required":["createdAt","id","name","updatedAt","variables"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"updatedAt":{"type":"string","format":"date-time"},"createdAt":{"type":"string","format":"date-time"},"variables":{"type":"array","items":{"type":"string"}}}},"PageTemplateProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/TemplateProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email template results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"PageSentEmailProjection":{"required":["content","number","numberOfElements","size","totalElements","totalPages"],"type":"object","properties":{"content":{"type":"array","description":"Collection of items","items":{"$ref":"#/components/schemas/SentEmailProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"size":{"type":"integer","description":"Size of page requested","format":"int32"},"number":{"type":"integer","description":"Page number starting at 0","format":"int32"},"totalPages":{"type":"integer","description":"Total number of pages available","format":"int32"},"numberOfElements":{"type":"integer","description":"Number of items returned","format":"int32"},"totalElements":{"type":"integer","description":"Total number of items available for querying","format":"int64"},"last":{"type":"boolean"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"empty":{"type":"boolean"}},"description":"Paginated sent email results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full sent email entity use the projection ID with individual method calls."},"SentEmailProjection":{"required":["attachments","bcc","cc","createdAt","id","inboxId","to","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"from":{"type":"string"},"userId":{"type":"string","format":"uuid"},"subject":{"type":"string"},"attachments":{"type":"array","items":{"type":"string"}},"createdAt":{"type":"string","format":"date-time"},"inboxId":{"type":"string","format":"uuid"},"to":{"type":"array","items":{"type":"string"}},"bcc":{"type":"array","items":{"type":"string"}},"cc":{"type":"array","items":{"type":"string"}},"bodyMD5Hash":{"type":"string"}},"description":"Collection of items"},"EmailPreviewUrls":{"required":["plainHtmlBodyUrl","rawSmtpMessageUrl"],"type":"object","properties":{"rawSmtpMessageUrl":{"type":"string"},"plainHtmlBodyUrl":{"type":"string"}}},"RawEmailJson":{"required":["content"],"type":"object","properties":{"content":{"type":"string"}},"description":"Content in raw format"},"PageInboxRulesetDto":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/InboxRulesetDto"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated inbox ruleset results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"MissedEmailProjection":{"required":["createdAt","id"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"from":{"type":"string"},"subject":{"type":"string"},"userId":{"type":"string","format":"uuid"},"createdAt":{"type":"string","format":"date-time"}}},"PageMissedEmailProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/MissedEmailProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated MissedEmail results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"MissedEmail":{"required":["attachmentCount","bcc","cc","createdAt","inboxIds","to","updatedAt"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"subject":{"type":"string"},"bodyExcerpt":{"type":"string"},"attachmentCount":{"type":"integer","format":"int32"},"from":{"type":"string"},"to":{"type":"array","items":{"type":"string"}},"cc":{"type":"array","items":{"type":"string"}},"bcc":{"type":"array","items":{"type":"string"}},"inboxIds":{"type":"array","items":{"type":"string","format":"uuid"}},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"}}},"PageUnknownMissedEmailProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/UnknownMissedEmailProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated unknown MissedEmail results. Unknown missed emails are emails that were sent to MailSlurp /Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"UnknownMissedEmailProjection":{"required":["createdAt","id"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"from":{"type":"string"},"subject":{"type":"string"},"to":{"type":"array","items":{"type":"string"}},"createdAt":{"type":"string","format":"date-time"}}},"PageEmailPreview":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/EmailPreview"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email preview results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments."},"CountDto":{"required":["totalElements"],"type":"object","properties":{"totalElements":{"type":"integer","format":"int64"}}},"InboxPreview":{"required":["createdAt","favourite","id","teamAccess"],"type":"object","properties":{"id":{"type":"string","description":"ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods `waitForLatestEmail` and `getEmails` methods respectively. Inboxes can be used with aliases to forward emails automatically.","format":"uuid"},"emailAddress":{"type":"string","description":"The inbox's email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so `+123` additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID."},"createdAt":{"type":"string","description":"When the inbox was created. Time stamps are in ISO DateTime Format `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` e.g. `2000-10-31T01:30:00.000-05:00`.","format":"date-time"},"favourite":{"type":"boolean","description":"Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering"},"name":{"type":"string","description":"Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search"},"tags":{"type":"array","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","items":{"type":"string","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI."}},"teamAccess":{"type":"boolean","description":"Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/"},"inboxType":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]},"expiresAt":{"type":"string","description":"Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email."}}},"PageInboxProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/InboxPreview"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"OrganizationInboxProjection":{"required":["createdAt","favourite","id","readOnly","teamAccess"],"type":"object","properties":{"id":{"type":"string","description":"ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods `waitForLatestEmail` and `getEmails` methods respectively. Inboxes can be used with aliases to forward emails automatically.","format":"uuid"},"createdAt":{"type":"string","description":"When the inbox was created. Time stamps are in ISO DateTime Format `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` e.g. `2000-10-31T01:30:00.000-05:00`.","format":"date-time"},"name":{"type":"string","description":"Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search"},"emailAddress":{"type":"string","description":"The inbox's email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so `+123` additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID."},"favourite":{"type":"boolean","description":"Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering"},"tags":{"type":"array","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.","items":{"type":"string","description":"Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI."}},"teamAccess":{"type":"boolean","description":"Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/"},"inboxType":{"type":"string","description":"Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).","enum":["HTTP_INBOX","SMTP_INBOX"]},"readOnly":{"type":"boolean","description":"Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes."}}},"PageOrganizationInboxProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/OrganizationInboxProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated organization inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"ImapSmtpAccessDetails":{"required":["imapPassword","imapServerHost","imapServerPort","imapUsername","smtpPassword","smtpServerHost","smtpServerPort","smtpUsername"],"type":"object","properties":{"smtpServerHost":{"type":"string"},"smtpServerPort":{"type":"integer","format":"int32"},"smtpUsername":{"type":"string"},"smtpPassword":{"type":"string"},"imapServerHost":{"type":"string"},"imapServerPort":{"type":"integer","format":"int32"},"imapUsername":{"type":"string"},"imapPassword":{"type":"string"}}},"InboxIdItem":{"required":["emailAddress","id"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"emailAddress":{"type":"string"}}},"InboxIdsResult":{"required":["inboxIds"],"type":"object","properties":{"inboxIds":{"type":"array","items":{"$ref":"#/components/schemas/InboxIdItem"}}}},"InboxExistsDto":{"required":["exists"],"type":"object","properties":{"exists":{"type":"boolean"}}},"InboxByEmailAddressResult":{"required":["exists"],"type":"object","properties":{"inboxId":{"type":"string","format":"uuid"},"exists":{"type":"boolean"}}},"GroupProjection":{"required":["createdAt","id","name"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"description":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}}},"ContactProjection":{"required":["createdAt","id"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"groupId":{"type":"string","format":"uuid"},"firstName":{"type":"string"},"lastName":{"type":"string"},"company":{"type":"string"},"emailAddresses":{"type":"array","items":{"type":"string"}},"optOut":{"type":"boolean"},"createdAt":{"type":"string","format":"date-time"}}},"PageContactProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/ContactProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated contact results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"PageGroupProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/GroupProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated missed email results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"PageInboxForwarderDto":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/InboxForwarderDto"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated inbox forwarder results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"ExpiredInboxRecordProjection":{"required":["createdAt","emailAddress","id","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"emailAddress":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}}},"PageExpiredInboxRecordProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/ExpiredInboxRecordProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated expired inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"ExpiredInboxDto":{"required":["emailAddress","id","inboxId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"emailAddress":{"type":"string"}},"description":"Expired inbox"},"ExpirationDefaults":{"required":["canPermanentInbox","nextInboxAllowsPermanent"],"type":"object","properties":{"defaultExpirationMillis":{"type":"integer","format":"int64"},"maxExpirationMillis":{"type":"integer","format":"int64"},"defaultExpiresAt":{"type":"string","format":"date-time"},"canPermanentInbox":{"type":"boolean"},"nextInboxAllowsPermanent":{"type":"boolean"}},"description":"Expiration defaults for your account"},"EmailProjection":{"required":["createdAt","id","inboxId","to"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"from":{"type":"string"},"teamAccess":{"type":"boolean"},"read":{"type":"boolean"},"subject":{"type":"string"},"attachments":{"type":"array","items":{"type":"string"}},"inboxId":{"type":"string","format":"uuid"},"to":{"type":"array","items":{"type":"string"}},"bcc":{"type":"array","items":{"type":"string"}},"cc":{"type":"array","items":{"type":"string"}},"createdAt":{"type":"string","format":"date-time"},"bodyMD5Hash":{"type":"string"},"bodyExcerpt":{"type":"string"}},"description":"A compact representation of a full email. Used in list endpoints to keep response sizes low. Body and attachments are not included. To get all fields of the email use the `getEmail` method with the email projection's ID. See `EmailDto` for documentation on projection properties."},"PageEmailProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/EmailProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email projection results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full email entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments."},"EmailTextLinesResult":{"required":["body","lines"],"type":"object","properties":{"lines":{"type":"array","items":{"type":"string"}},"body":{"type":"string"}},"description":"Parsed text of an email"},"EmailLinksResult":{"required":["body","links"],"type":"object","properties":{"links":{"type":"array","items":{"type":"string"}},"body":{"type":"string"}},"description":"Links found in HTML"},"DownloadAttachmentDto":{"required":["base64FileContents","contentType","sizeBytes"],"type":"object","properties":{"base64FileContents":{"type":"string","description":"Base64 encoded string of attachment bytes. Decode the base64 encoded string to get the raw contents. If the file has a content type such as `text/html` you can read the contents directly by converting it to string using `utf-8` encoding."},"contentType":{"type":"string","description":"Content type of attachment. Examples are `image/png`, `application/msword`, `text/csv` etc."},"sizeBytes":{"type":"integer","description":"Size in bytes of attachment content","format":"int64"}},"description":"Content of attachment"},"UnreadCount":{"required":["count"],"type":"object","properties":{"count":{"type":"integer","format":"int64"}}},"GravatarUrl":{"required":["hash","url"],"type":"object","properties":{"url":{"type":"string"},"hash":{"type":"string"}}},"EmailValidationRequest":{"required":["createdAt","emailAddress","isValid","updatedAt","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"emailAddress":{"type":"string"},"isValid":{"type":"boolean"},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"}}},"PageEmailValidationRequest":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/EmailValidationRequest"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email validation request records. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"DomainPreview":{"required":["createdAt","domain","domainType","id","isVerified"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"domain":{"type":"string"},"catchAllInboxId":{"type":"string","format":"uuid"},"createdAt":{"type":"string","format":"date-time"},"domainType":{"type":"string","description":"Type of domain. Dictates type of inbox that can be created with domain. HTTP means inboxes are processed using SES while SMTP inboxes use a custom SMTP mail server. SMTP does not support sending so use HTTP for sending emails.","enum":["HTTP_INBOX","SMTP_DOMAIN"]},"isVerified":{"type":"boolean"}},"description":"Preview object for domain entity"},"BounceRecipient":{"required":["createdAt","recipient","updatedAt"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"recipient":{"type":"string"},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"}}},"PageBouncedRecipients":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/BounceRecipient"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated bounced recipients. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"BouncedRecipientDto":{"required":["createdAt","recipient"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"recipient":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}},"description":"Bounced recipient"},"BounceProjection":{"required":["createdAt","sender"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"sender":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}}},"PageBouncedEmail":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/BounceProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated bounced email. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"BouncedEmailDto":{"required":["createdAt","notificationType","sender","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"userId":{"type":"string","format":"uuid"},"notificationType":{"type":"string"},"sentToRecipients":{"type":"array","items":{"type":"string"}},"sender":{"type":"string"},"bounceMta":{"type":"string"},"bounceType":{"type":"string"},"bounceRecipients":{"type":"array","items":{"type":"string"}},"bounceSubType":{"type":"string"},"createdAt":{"type":"string","format":"date-time"}},"description":"Bounced email"},"AttachmentProjection":{"required":["attachmentId","createdAt","updatedAt","userId"],"type":"object","properties":{"name":{"type":"string"},"contentLength":{"type":"integer","description":"Content length of attachment in bytes","format":"int64"},"contentType":{"type":"string","description":"Content type of attachment.","example":"image/png"},"updatedAt":{"type":"string","format":"date-time"},"userId":{"type":"string","format":"uuid"},"attachmentId":{"type":"string","description":"Attachment ID"},"createdAt":{"type":"string","format":"date-time"}}},"PageAttachmentEntity":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/AttachmentProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated attachment entity results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"AttachmentEntity":{"required":["attachmentId","createdAt","updatedAt","userId"],"type":"object","properties":{"id":{"type":"string","format":"uuid"},"attachmentId":{"type":"string"},"userId":{"type":"string","format":"uuid"},"contentType":{"type":"string"},"contentLength":{"type":"integer","format":"int64"},"name":{"type":"string"},"createdAt":{"type":"string","format":"date-time"},"updatedAt":{"type":"string","format":"date-time"}}},"AliasProjection":{"required":["createdAt","emailAddress","id","inboxId","updatedAt","userId"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"updatedAt":{"type":"string","format":"date-time"},"userId":{"type":"string","format":"uuid"},"emailAddress":{"type":"string"},"inboxId":{"type":"string","format":"uuid"},"createdAt":{"type":"string","format":"date-time"},"useThreads":{"type":"boolean"}},"description":"Representation of a alias"},"PageAlias":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/AliasProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email alias results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls."},"PageThreadProjection":{"type":"object","properties":{"content":{"type":"array","items":{"$ref":"#/components/schemas/ThreadProjection"}},"pageable":{"$ref":"#/components/schemas/PageableObject"},"total":{"type":"integer","format":"int64","writeOnly":true},"last":{"type":"boolean"},"totalPages":{"type":"integer","format":"int32"},"totalElements":{"type":"integer","format":"int64"},"size":{"type":"integer","format":"int32"},"number":{"type":"integer","format":"int32"},"sort":{"$ref":"#/components/schemas/Sort"},"first":{"type":"boolean"},"numberOfElements":{"type":"integer","format":"int32"},"empty":{"type":"boolean"}},"description":"Paginated email projection results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full email entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments."},"ThreadProjection":{"required":["aliasId","createdAt","id","inboxId","to","updatedAt","userId"],"type":"object","properties":{"name":{"type":"string"},"id":{"type":"string","format":"uuid"},"updatedAt":{"type":"string","format":"date-time"},"subject":{"type":"string"},"userId":{"type":"string","format":"uuid"},"inboxId":{"type":"string","format":"uuid"},"to":{"type":"array","items":{"type":"string"}},"bcc":{"type":"array","items":{"type":"string"}},"cc":{"type":"array","items":{"type":"string"}},"createdAt":{"type":"string","format":"date-time"},"aliasId":{"type":"string","format":"uuid"}},"description":"A thread is a message thread created for a message received by an alias"},"FlushExpiredInboxesResult":{"required":["expireBefore","inboxIds"],"type":"object","properties":{"inboxIds":{"type":"array","items":{"type":"string","format":"uuid"}},"expireBefore":{"type":"string","format":"date-time"}}}},"securitySchemes":{"API_KEY":{"type":"apiKey","description":"Set x-api-key API KEY header in your client to your MailSlurp API Key value.","name":"x-api-key","in":"header"}}}}